<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue | 我的前端态度</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="记录自己的学习考古，会前端真的可以“为所欲为”maybe">
    
    <link rel="preload" href="/fe-attitude/assets/css/0.styles.52e064f1.css" as="style"><link rel="preload" href="/fe-attitude/assets/js/app.7a42581c.js" as="script"><link rel="preload" href="/fe-attitude/assets/js/2.e3af99bf.js" as="script"><link rel="preload" href="/fe-attitude/assets/js/5.e978ac0b.js" as="script"><link rel="prefetch" href="/fe-attitude/assets/js/10.1fd95463.js"><link rel="prefetch" href="/fe-attitude/assets/js/11.755b0182.js"><link rel="prefetch" href="/fe-attitude/assets/js/12.56a246bd.js"><link rel="prefetch" href="/fe-attitude/assets/js/13.1596e74a.js"><link rel="prefetch" href="/fe-attitude/assets/js/14.d48716cc.js"><link rel="prefetch" href="/fe-attitude/assets/js/15.0725d236.js"><link rel="prefetch" href="/fe-attitude/assets/js/16.0f38748a.js"><link rel="prefetch" href="/fe-attitude/assets/js/17.92bbb27c.js"><link rel="prefetch" href="/fe-attitude/assets/js/18.a88d8c5a.js"><link rel="prefetch" href="/fe-attitude/assets/js/19.5a9238e7.js"><link rel="prefetch" href="/fe-attitude/assets/js/20.b508093b.js"><link rel="prefetch" href="/fe-attitude/assets/js/21.7c7ee976.js"><link rel="prefetch" href="/fe-attitude/assets/js/22.0d643ddd.js"><link rel="prefetch" href="/fe-attitude/assets/js/23.0eb45118.js"><link rel="prefetch" href="/fe-attitude/assets/js/24.5e1a2929.js"><link rel="prefetch" href="/fe-attitude/assets/js/25.25df588f.js"><link rel="prefetch" href="/fe-attitude/assets/js/26.86a3e548.js"><link rel="prefetch" href="/fe-attitude/assets/js/27.7570be2e.js"><link rel="prefetch" href="/fe-attitude/assets/js/28.99948a2f.js"><link rel="prefetch" href="/fe-attitude/assets/js/29.57d23ed2.js"><link rel="prefetch" href="/fe-attitude/assets/js/3.7a47e54d.js"><link rel="prefetch" href="/fe-attitude/assets/js/30.cded95ab.js"><link rel="prefetch" href="/fe-attitude/assets/js/31.673a888b.js"><link rel="prefetch" href="/fe-attitude/assets/js/32.dcadbc94.js"><link rel="prefetch" href="/fe-attitude/assets/js/4.1fdba925.js"><link rel="prefetch" href="/fe-attitude/assets/js/6.4d20b163.js"><link rel="prefetch" href="/fe-attitude/assets/js/7.aae27088.js"><link rel="prefetch" href="/fe-attitude/assets/js/8.310cc6b9.js"><link rel="prefetch" href="/fe-attitude/assets/js/9.98b0c5fd.js">
    <link rel="stylesheet" href="/fe-attitude/assets/css/0.styles.52e064f1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/fe-attitude/" class="home-link router-link-active"><!----> <span class="site-name">我的前端态度</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="构建知识体系" class="dropdown-title"><span class="title">构建知识体系</span> <span class="arrow down"></span></button> <button type="button" aria-label="构建知识体系" class="mobile-dropdown-title"><span class="title">构建知识体系</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/fe-attitude/fe/self-check.html" class="nav-link">
  自检
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/html.html" class="nav-link">
  Html
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/javascript.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/typescript.html" class="nav-link">
  TypeScript
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/write.html" class="nav-link">
  手写代码
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/console.html" class="nav-link">
  输出结果
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/design.html" class="nav-link">
  设计模式
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/browser.html" class="nav-link">
  浏览器
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/network.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/algorithm.html" class="nav-link">
  算法
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/vue.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Vue
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/react.html" class="nav-link">
  React
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/node.html" class="nav-link">
  Node
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/skill.html" class="nav-link">
  编程技巧
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/engineering.html" class="nav-link">
  工程化
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="专题学习计划" class="dropdown-title"><span class="title">专题学习计划</span> <span class="arrow down"></span></button> <button type="button" aria-label="专题学习计划" class="mobile-dropdown-title"><span class="title">专题学习计划</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          正则表达式
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/113" target="_blank" rel="noopener noreferrer" class="nav-link external">
  正则手记——语法篇
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/245" target="_blank" rel="noopener noreferrer" class="nav-link external">
  正则手记——方法篇
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/230" target="_blank" rel="noopener noreferrer" class="nav-link external">
  正则手记——实例篇
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          前端常见需求的解决方案
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/248" target="_blank" rel="noopener noreferrer" class="nav-link external">
  玩转异步
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          组件库源码学习课
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/250" target="_blank" rel="noopener noreferrer" class="nav-link external">
  vant2 popup 源码学习
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/268" target="_blank" rel="noopener noreferrer" class="nav-link external">
  跟着 Vant Dialog 学习函数调用使用组件
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          Vue 源码解读
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/274" target="_blank" rel="noopener noreferrer" class="nav-link external">
  探索 Vue.js 内部运行机制
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="使用资源" class="dropdown-title"><span class="title">使用资源</span> <span class="arrow down"></span></button> <button type="button" aria-label="使用资源" class="mobile-dropdown-title"><span class="title">使用资源</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          推荐资源
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/fe-attitude/use/website.html" class="nav-link">
  在线工具
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/use/tutorial.html" class="nav-link">
  在线教程
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/use/repos.html" class="nav-link">
  前端库与框架
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/use/articles.html" class="nav-link">
  优秀文章
</a></li></ul></li><li class="dropdown-item"><h4>
          打造舒适、高效、时尚的前端开发环境
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/3" target="_blank" rel="noopener noreferrer" class="nav-link external">
  开发环境的搭建（含 Chrome 配置）
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues?q=is%3Aissue+is%3Aopen+in%3Atitle+git" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Git 协作
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/42" target="_blank" rel="noopener noreferrer" class="nav-link external">
  玩好 Terminal 终端 
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/185" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VS Code 编辑器配置 
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/204" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Whistle 代理抓包 
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues?q=is%3Aissue+is%3Aopen+in%3Atitle+node" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Node.js 相关
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/278" target="_blank" rel="noopener noreferrer" class="nav-link external">
  拥抱 AI
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/fe-attitude/tools/format-Markdown.html" class="nav-link">
  Markdown 格式化工具
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/tools/docx-to-html.html" class="nav-link">
  docx 转 html
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/tools/regex.html" class="nav-link">
  正则表达式生成器
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="我的 Reops" class="dropdown-title"><span class="title">我的 Reops</span> <span class="arrow down"></span></button> <button type="button" aria-label="我的 Reops" class="mobile-dropdown-title"><span class="title">我的 Reops</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          原创作品
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/node-crawler" target="_blank" rel="noopener noreferrer" class="nav-link external">
  node 爬虫自用工具
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/beyond-ui" target="_blank" rel="noopener noreferrer" class="nav-link external">
  beyond-ui
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://yanyue404.github.io/dev-admin/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  用于开发的管理工具
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/nuxt-issue-blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub Issue 博客静态站点生成
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/build-my-own-extension" target="_blank" rel="noopener noreferrer" class="nav-link external">
  油猴脚本 &amp; 浏览器扩展
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/vscode-extension-ts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VS Code 快速语音笔记插件
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          Npm
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/yanyue404/rainbow-shared" target="_blank" rel="noopener noreferrer" class="nav-link external">
  rainbow 的 实用函数
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/issues2md" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Export Github Issues to markdown file
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          开源项目文档（Fork)
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://yanyue404.github.io/vant/#/zh-CN" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vant 组件库
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://yanyue404.github.io/element/#/zh-CN/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Element 组件库
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://yanyue404.github.io/vue-design/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue 技术内幕
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://yanyue404.github.io/vue2/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue 2 官方文档
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://yanyue404.github.io/vue-template-compiler-playground/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue 模板编译器 Playground
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          其他兴趣
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://yanyue404.github.io/mingdao/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  记录王明道先生的文字
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/cook" target="_blank" rel="noopener noreferrer" class="nav-link external">
  How to Cook
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div> <a href="https://github.com/yanyue404/fe-attitude" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="构建知识体系" class="dropdown-title"><span class="title">构建知识体系</span> <span class="arrow down"></span></button> <button type="button" aria-label="构建知识体系" class="mobile-dropdown-title"><span class="title">构建知识体系</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/fe-attitude/fe/self-check.html" class="nav-link">
  自检
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/html.html" class="nav-link">
  Html
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/javascript.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/typescript.html" class="nav-link">
  TypeScript
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/write.html" class="nav-link">
  手写代码
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/console.html" class="nav-link">
  输出结果
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/design.html" class="nav-link">
  设计模式
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/browser.html" class="nav-link">
  浏览器
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/network.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/algorithm.html" class="nav-link">
  算法
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/vue.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Vue
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/react.html" class="nav-link">
  React
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/node.html" class="nav-link">
  Node
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/skill.html" class="nav-link">
  编程技巧
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/fe/engineering.html" class="nav-link">
  工程化
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="专题学习计划" class="dropdown-title"><span class="title">专题学习计划</span> <span class="arrow down"></span></button> <button type="button" aria-label="专题学习计划" class="mobile-dropdown-title"><span class="title">专题学习计划</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          正则表达式
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/113" target="_blank" rel="noopener noreferrer" class="nav-link external">
  正则手记——语法篇
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/245" target="_blank" rel="noopener noreferrer" class="nav-link external">
  正则手记——方法篇
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/230" target="_blank" rel="noopener noreferrer" class="nav-link external">
  正则手记——实例篇
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          前端常见需求的解决方案
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/248" target="_blank" rel="noopener noreferrer" class="nav-link external">
  玩转异步
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          组件库源码学习课
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/250" target="_blank" rel="noopener noreferrer" class="nav-link external">
  vant2 popup 源码学习
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/268" target="_blank" rel="noopener noreferrer" class="nav-link external">
  跟着 Vant Dialog 学习函数调用使用组件
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          Vue 源码解读
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/274" target="_blank" rel="noopener noreferrer" class="nav-link external">
  探索 Vue.js 内部运行机制
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="使用资源" class="dropdown-title"><span class="title">使用资源</span> <span class="arrow down"></span></button> <button type="button" aria-label="使用资源" class="mobile-dropdown-title"><span class="title">使用资源</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          推荐资源
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/fe-attitude/use/website.html" class="nav-link">
  在线工具
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/use/tutorial.html" class="nav-link">
  在线教程
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/use/repos.html" class="nav-link">
  前端库与框架
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/use/articles.html" class="nav-link">
  优秀文章
</a></li></ul></li><li class="dropdown-item"><h4>
          打造舒适、高效、时尚的前端开发环境
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/3" target="_blank" rel="noopener noreferrer" class="nav-link external">
  开发环境的搭建（含 Chrome 配置）
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues?q=is%3Aissue+is%3Aopen+in%3Atitle+git" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Git 协作
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/42" target="_blank" rel="noopener noreferrer" class="nav-link external">
  玩好 Terminal 终端 
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/185" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VS Code 编辑器配置 
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/204" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Whistle 代理抓包 
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues?q=is%3Aissue+is%3Aopen+in%3Atitle+node" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Node.js 相关
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues/278" target="_blank" rel="noopener noreferrer" class="nav-link external">
  拥抱 AI
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/fe-attitude/tools/format-Markdown.html" class="nav-link">
  Markdown 格式化工具
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/tools/docx-to-html.html" class="nav-link">
  docx 转 html
</a></li><li class="dropdown-subitem"><a href="/fe-attitude/tools/regex.html" class="nav-link">
  正则表达式生成器
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="我的 Reops" class="dropdown-title"><span class="title">我的 Reops</span> <span class="arrow down"></span></button> <button type="button" aria-label="我的 Reops" class="mobile-dropdown-title"><span class="title">我的 Reops</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          原创作品
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/yanyue404/blog/issues" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/node-crawler" target="_blank" rel="noopener noreferrer" class="nav-link external">
  node 爬虫自用工具
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/beyond-ui" target="_blank" rel="noopener noreferrer" class="nav-link external">
  beyond-ui
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://yanyue404.github.io/dev-admin/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  用于开发的管理工具
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/nuxt-issue-blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub Issue 博客静态站点生成
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/build-my-own-extension" target="_blank" rel="noopener noreferrer" class="nav-link external">
  油猴脚本 &amp; 浏览器扩展
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/vscode-extension-ts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VS Code 快速语音笔记插件
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          Npm
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/yanyue404/rainbow-shared" target="_blank" rel="noopener noreferrer" class="nav-link external">
  rainbow 的 实用函数
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/issues2md" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Export Github Issues to markdown file
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          开源项目文档（Fork)
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://yanyue404.github.io/vant/#/zh-CN" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vant 组件库
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://yanyue404.github.io/element/#/zh-CN/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Element 组件库
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://yanyue404.github.io/vue-design/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue 技术内幕
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://yanyue404.github.io/vue2/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue 2 官方文档
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://yanyue404.github.io/vue-template-compiler-playground/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue 模板编译器 Playground
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>
          其他兴趣
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://yanyue404.github.io/mingdao/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  记录王明道先生的文字
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://github.com/yanyue404/cook" target="_blank" rel="noopener noreferrer" class="nav-link external">
  How to Cook
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></div></div> <a href="https://github.com/yanyue404/fe-attitude" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-attitude/fe/vue.html#什么是-mvvm" class="sidebar-link">什么是 mvvm</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-的响应式系统原理" class="sidebar-link">Vue 的响应式系统原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#对于生命周期的理解" class="sidebar-link">对于生命周期的理解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#父子组件生命周期执行顺序" class="sidebar-link">父子组件生命周期执行顺序</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#源码的生命周期" class="sidebar-link">源码的生命周期</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#为什么组件的-data-必须是一个函数" class="sidebar-link">为什么组件的 data 必须是一个函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#常见的事件修饰符及其作用" class="sidebar-link">常见的事件修饰符及其作用</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-extend-能做什么" class="sidebar-link">Vue.extend 能做什么</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#mixin-和-mixins-区别" class="sidebar-link">mixin 和 mixins 区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#computed-和-watch-的区别" class="sidebar-link">computed 和 watch 的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-中的-computed-是如何实现的" class="sidebar-link">Vue 中的 computed 是如何实现的</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#watch-原理" class="sidebar-link">watch 原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#v-show-与-v-if-区别" class="sidebar-link">v-show 与 v-if 区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue2-数组的响应性支持情况如何" class="sidebar-link">Vue2 数组的响应性支持情况如何</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#组件间通信" class="sidebar-link">组件间通信</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#双向绑定原理" class="sidebar-link">双向绑定原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#自定义组件的语法糖-v-model-是怎样实现的" class="sidebar-link">自定义组件的语法糖 v-model 是怎样实现的</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#keep-alive-有什么作用" class="sidebar-link">keep-alive 有什么作用</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-keep-alive-组件原理详解" class="sidebar-link">Vue keep-alive 组件原理详解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#如何强制刷新-vue-组件" class="sidebar-link">如何强制刷新 Vue 组件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-为何是异步渲染" class="sidebar-link">Vue 为何是异步渲染</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#nexttick" class="sidebar-link">nextTick</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-事件绑定原理说一下" class="sidebar-link">Vue 事件绑定原理说一下</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#slot-是什么-有什么作用-原理是什么" class="sidebar-link">slot 是什么？有什么作用？原理是什么？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-模板渲染的原理是什么" class="sidebar-link">Vue 模板渲染的原理是什么？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#template-预编译是什么" class="sidebar-link">template 预编译是什么？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#那-template-和-jsx-的有什么分别" class="sidebar-link">那 template 和 jsx 的有什么分别？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#virtual-dom" class="sidebar-link">Virtual DOM</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#介绍一下-vue-中的-diff-算法" class="sidebar-link">介绍一下 Vue 中的 Diff 算法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-中-key-的作用" class="sidebar-link">Vue 中 key 的作用</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-怎么实现页面的权限控制" class="sidebar-link">vue 怎么实现页面的权限控制</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-router-基础" class="sidebar-link">vue-router 基础</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#route-和-router-的区别" class="sidebar-link">$route 和$router 的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#路由原理" class="sidebar-link">路由原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vuex-基础" class="sidebar-link">vuex 基础</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#为什么-vuex-的-mutation-中不能做异步操作" class="sidebar-link">为什么 Vuex 的 mutation 中不能做异步操作？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vuex-原理" class="sidebar-link">vuex 原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-和-react-之间的区别" class="sidebar-link">Vue 和 React 之间的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-3-对比-vue-2-做了哪些改动" class="sidebar-link">Vue 3 对比 Vue 2 做了哪些改动？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#proxy-相比于-defineproperty-的优势" class="sidebar-link">Proxy 相比于 defineProperty 的优势</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-3-为什么使用-composition-api" class="sidebar-link">Vue 3 为什么使用 Composition API？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-cli4、vue-cli43、vue-cli2-的区别" class="sidebar-link">vue-cli4、vue-cli43、vue-cli2 的区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#如何设计一个通用组件" class="sidebar-link">如何设计一个通用组件？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#在-vs-code-中调试-vue" class="sidebar-link">在 VS Code 中调试 Vue</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-渲染大量数据时应该怎么优化" class="sidebar-link">vue 渲染大量数据时应该怎么优化？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-如何优化首页的加载速度-vue-首页白屏是什么问题引起的-如何解决呢" class="sidebar-link">vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#v-if、v-show、v-html-的原理是什么-它是如何封装的" class="sidebar-link">v-if、v-show、v-html 的原理是什么，它是如何封装的？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-在-v-for-时给每项元素绑定事件需要用事件代理吗-为什么" class="sidebar-link">vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue-ssr-有了解吗-原理是什么" class="sidebar-link">Vue SSR 有了解吗？原理是什么？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#服务器端渲染-vs-预渲染-ssr-vs-prerendering" class="sidebar-link">服务器端渲染 vs 预渲染 (SSR vs Prerendering)</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#什么是预渲染-ssg" class="sidebar-link">什么是预渲染(SSG)</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#ssg-vs-ssr" class="sidebar-link">SSG vs SSR</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#我应该使用预渲染吗" class="sidebar-link">我应该使用预渲染吗？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#让-vue-使用指定配置文件进行构建" class="sidebar-link">让 Vue 使用指定配置文件进行构建</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#理解-vue3-composables" class="sidebar-link">理解 Vue3 composables</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#如何编写一个可以在-vue2-和-vue3-项目同时可用的-vue-组件" class="sidebar-link">如何编写一个可以在 Vue2 和 Vue3 项目同时可用的 Vue 组件？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#vue3-的渲染函数做了如何变化" class="sidebar-link">Vue3 的渲染函数做了如何变化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe-attitude/fe/vue.html#渲染函数参数" class="sidebar-link">渲染函数参数</a></li><li class="sidebar-sub-header"><a href="/fe-attitude/fe/vue.html#vnode-prop-格式化" class="sidebar-link">VNode Prop 格式化</a></li><li class="sidebar-sub-header"><a href="/fe-attitude/fe/vue.html#注册组件" class="sidebar-link">注册组件</a></li></ul></li><li><a href="/fe-attitude/fe/vue.html#调试线上-vue-组件" class="sidebar-link">调试线上 vue 组件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe-attitude/fe/vue.html#当我们在写-vue2-和-vue3-的代码时-使用-nexttick-时意味着什么" class="sidebar-link">当我们在写 vue2 和 vue3 的代码时，使用 nextTick(() =&gt; {}) 时意味着什么</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe-attitude/fe/vue.html#_1-背景-vue-的响应式更新机制" class="sidebar-link">1. 背景：Vue 的响应式更新机制</a></li><li class="sidebar-sub-header"><a href="/fe-attitude/fe/vue.html#_2-nexttick-的作用" class="sidebar-link">2. `nextTick` 的作用</a></li><li class="sidebar-sub-header"><a href="/fe-attitude/fe/vue.html#_3-具体含义" class="sidebar-link">3. 具体含义</a></li><li class="sidebar-sub-header"><a href="/fe-attitude/fe/vue.html#_4-使用场景" class="sidebar-link">4. 使用场景</a></li><li class="sidebar-sub-header"><a href="/fe-attitude/fe/vue.html#_5-vue2-和-vue3-的差异" class="sidebar-link">5. Vue2 和 Vue3 的差异</a></li><li class="sidebar-sub-header"><a href="/fe-attitude/fe/vue.html#_6-注意事项" class="sidebar-link">6. 注意事项</a></li><li class="sidebar-sub-header"><a href="/fe-attitude/fe/vue.html#_7-总结" class="sidebar-link">7. 总结</a></li></ul></li><li><a href="/fe-attitude/fe/vue.html#参考链接" class="sidebar-link">参考链接</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue"><a href="#vue" class="header-anchor">#</a> Vue</h1> <blockquote><p>GitHub Pages 在线访问最新：<a href="https://yanyue404.github.io/fe-attitude/" target="_blank" rel="noopener noreferrer">我的前端态度 —— 前端知识体系<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p></blockquote> <h2 id="什么是-mvvm"><a href="#什么是-mvvm" class="header-anchor">#</a> 什么是 mvvm</h2> <p>MVVM 最早由微软提出来，它借鉴了桌面应用程序的 MVC 思想，在前端页面中，把 Model 用纯 JavaScript 对象表示，View 负责显示，两者做到了最大限度的分离 把 Model 和 View 关联起来的就是 ViewModel。</p> <p>ViewModel 负责把 Model 的数据同步到 View 显示出来，还负责把 View 的修改同步回 Model，View 和 Model 之间的同步工作完全是自动的，无需人为干涉（由 viewModel 完成，在这里指 VUE）。</p> <p>因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p> <h2 id="vue-的响应式系统原理"><a href="#vue-的响应式系统原理" class="header-anchor">#</a> Vue 的响应式系统原理</h2> <p><img src="/fe-attitude/assets/img/data.992960d2.png" alt=""></p> <p>Vue 为 MVVM 框架，当数据模型 data 变化时，页面视图会得到响应更新，其原理对 data 的 getter/setter 方法进行拦截（Object.defineProperty 或者 Proxy），利用发布订阅的设计模式，在 getter 方法中进行订阅，在 setter 方法中发布通知，让所有订阅者完成响应。</p> <p>在响应式系统中，Vue 会为数据模型 <code>data</code> 的每一个属性新建一个订阅中心作为发布者，而监听器 <code>watch</code>、计算属性 <code>computed</code>、视图渲染 <code>template/render</code> 三个角色同时作为订阅者，对于监听器 watch，会直接订阅观察监听的属性，对于计算属性 computed 和视图渲染 template/render，如果内部执行获取了 data 的某个属性，就会执行该属性的 getter 方法，然后自动完成对该属性的订阅，当属性被修改时，就会执行该属性的 <code>setter</code> 方法，从而完成该属性的发布通知，通知所有订阅者进行更新。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 简易版响应式原理</span>
<span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">price</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token literal-property property">quantity</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> target <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token comment">// Our simple Dep class</span>
<span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>subscribers<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Only if there is a target &amp; it's not already subscribed</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">sub</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Go through each of our data properties</span>
Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> internalValue <span class="token operator">=</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span>

  <span class="token comment">// Each property gets a dependency instance</span>
  <span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &lt;-- Remember the target we're running</span>
      <span class="token keyword">return</span> internalValue
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      internalValue <span class="token operator">=</span> newVal
      dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &lt;-- Re-run stored functions</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// The code to watch to listen for reactive properties</span>
<span class="token keyword">function</span> <span class="token function">watcher</span><span class="token punctuation">(</span><span class="token parameter">myFunc</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  target <span class="token operator">=</span> myFunc
  <span class="token function">target</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  target <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>

<span class="token function">watcher</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  data<span class="token punctuation">.</span>total <span class="token operator">=</span> data<span class="token punctuation">.</span>price <span class="token operator">*</span> data<span class="token punctuation">.</span>quantity
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'total = '</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>total<span class="token punctuation">)</span>
data<span class="token punctuation">.</span>price <span class="token operator">=</span> <span class="token number">20</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'total = '</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>total<span class="token punctuation">)</span>
data<span class="token punctuation">.</span>quantity <span class="token operator">=</span> <span class="token number">10</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'total = '</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>total<span class="token punctuation">)</span>
</code></pre></div><p>数据响应的实现由两部分构成: <strong>观察者( Observe )</strong>   和  <strong>依赖收集器( Dep )</strong> ，其核心是  <code>defineProperty</code>这个方法，它可以  <strong>重写属性的 get 与 set</strong>  方法，从而完成监听数据的改变。</p> <ul><li>Observe (观察者)观察 props 与 state
<ul><li>遍历 props 与 state，对每个属性创建独立的监听器( watcher )</li></ul></li> <li>使用  <code>defineProperty</code>  重写每个属性的 get/set(<code>defineReactive</code>）
<ul><li><code>get</code>: 收集依赖
<ul><li><code>Dep.depend()</code> <ul><li><code>watcher.addDep()</code></li></ul></li></ul></li> <li><code>set</code>: 派发更新
<ul><li><code>Dep.notify()</code></li> <li><code>watcher.update()</code></li> <li><code>queenWatcher()</code></li> <li><code>nextTick</code></li> <li><code>flushScheduleQueue</code></li> <li><code>watcher.run()</code></li> <li><code>updateComponent()</code></li></ul></li></ul></li></ul> <p>大家可以先看下面的数据相应的代码实现后，理解后就比较容易看懂上面的简单脉络了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token comment">// 数据响应性</span>
<span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>

<span class="token comment">// 初始化观察者</span>
<span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> updateComponent<span class="token punctuation">)</span>
data<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span>

<span class="token comment">// 简单表示用于数据更新后的操作</span>
<span class="token keyword">function</span> <span class="token function">updateComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// patchs</span>
<span class="token punctuation">}</span>

<span class="token comment">// 监视对象</span>
<span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 遍历对象，使用 get/set 重新定义对象的每个属性值</span>
  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 递归子属性</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token function">observe</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>

  <span class="token comment">// 新建依赖收集器</span>
  <span class="token keyword">let</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 定义get/set</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当有获取该属性时，证明依赖于该对象，因此被添加进收集器中</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> v
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 重新设置值时，触发收集器的通知机制</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span><span class="token punctuation">(</span><span class="token parameter">nV</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      v <span class="token operator">=</span> nV
      dep<span class="token punctuation">.</span><span class="token function">nofify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 依赖收集器</span>
<span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token function">addSub</span><span class="token punctuation">(</span><span class="token parameter">sub</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">sub</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      sub<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token comment">// 观察者</span>
<span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb
    <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> obj
    <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token function">addDep</span><span class="token punctuation">(</span><span class="token parameter">Dep</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>key<span class="token punctuation">]</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span><span class="token string">'beforeUpdate'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>参考链接</p> <ul><li><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener noreferrer">https://cn.vuejs.org/v2/guide/reactivity.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.vuemastery.com/courses/advanced-components/build-a-reactivity-system/" target="_blank" rel="noopener noreferrer">https://www.vuemastery.com/courses/advanced-components/build-a-reactivity-system/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="对于生命周期的理解"><a href="#对于生命周期的理解" class="header-anchor">#</a> 对于生命周期的理解</h2> <p>创建一个 Vue 实例，是一个漫长的过程，要经历初始化，数据合并，模板解析，数据渲染等等一系列过程。 所以，为了能实现在这个过程里面插入自己想要提前做的事情，就有了生命周期钩子函数。</p> <ol><li>create x 2 (before + ed)（SSR 可用）</li> <li>mount x 2 （before + ed）（SSR 阶段不可用）</li> <li>update x 2</li> <li>destroy x 2</li></ol> <p>还有三个写在<a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" target="_blank" rel="noopener noreferrer">钩子列表<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>里：</p> <ol><li>activated（被 keep-alive 缓存的组件激活时调用）</li> <li>deactivated（被 keep-alive 缓存的组件失活时调用）</li> <li>errorCaptured</li></ol> <p>Vue 中的生命周期也是一样，对应了 Vue 实例从创建到结束之间的每一个过程。 例如，Vue 的<code>beforeCreate</code>周期，指的就是 Vue 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p> <p>Vue.js 生命周期 主要有 8 个阶段：</p> <ul><li><p>创建前 / 后（beforeCreate / created）：在 beforeCreate 阶段，Vue 实例的挂载元素 el 和 data、methods、computed 以及 watch 上的数据和方法都不能被访问，还未初始化。在 created 阶段，Vue 实例的数据对象 data 有了，el 还没有。在当前阶段无法与 Dom 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 Dom。</p> <ul><li>可以在 create 中发起请求，能更快获取到服务端数据，1.减少页面 loading 时间；2.ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul></li> <li><p>载入前 / 后（beforeMount / mounted）：在 beforeMount 为发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段虚拟 Dom 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 updated。在 mounted 阶段 ，在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点，使用$refs 属性对 Dom 进行操作。</p></li> <li><p>更新前 / 后（beforeUpdate / updated）：beforeUpdate 发生在更新之前，也就是响应式数据发生更新，虚拟 dom 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。updated 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p></li> <li><p>销毁前 / 后（beforeDestroy / destroyed）：beforeDestroy 是在 Vue 实例销毁前触发，一般在这里要通过 removeEventListener 解除手动绑定的事件。destroyed 发生在实例销毁之后，这个时候只剩下了 dom 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p></li></ul> <p>至于 Vue 具体的生命周期函数有哪些，请看官网<a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" target="_blank" rel="noopener noreferrer">API 文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="父子组件生命周期执行顺序"><a href="#父子组件生命周期执行顺序" class="header-anchor">#</a> 父子组件生命周期执行顺序</h2> <p>1.加载渲染过程</p> <p>父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted</p> <p>2.子组件更新过程</p> <p>父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p> <p>3.父组件更新过程</p> <p>父 beforeUpdate-&gt;父 updated</p> <p>4.销毁过程</p> <p>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p> <blockquote><p>总结：从外到内，再从内到外</p></blockquote> <p>注意  <code>mounted</code>  不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在  <code>mounted</code>  内部使用  <code>vm.$nextTick</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">mounted</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Code that will run only after the</span>
    <span class="token comment">// entire view has been rendered</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="源码的生命周期"><a href="#源码的生命周期" class="header-anchor">#</a> 源码的生命周期</h2> <ul><li><p><code>_init_</code></p> <ul><li><p><code>initLifecycle/Event</code>，往<code>vm</code>上挂载各种属性</p></li> <li><p><code>callHook: beforeCreated</code>: 实例刚创建</p></li> <li><p><code>initInjection/initState</code>: 初始化注入和 data 响应性</p></li> <li><p><code>created</code>: 创建完成，属性已经绑定， 但还未生成真实<code>dom</code></p></li> <li><p>进行元素的挂载： <code>$el / vm.$mount()</code></p></li> <li><p>是否有<code>template</code>: 解析成<code>render function</code></p> <ul><li><code>*.vue</code>文件: <code>vue-loader</code>会将<code>&lt;template&gt;</code>编译成<code>render function</code></li></ul></li> <li><p><code>beforeMount</code>: 模板编译/挂载之前</p></li> <li><p>执行<code>render function</code>，生成真实的<code>dom</code>，并替换到<code>dom tree</code>中</p></li> <li><p><code>mounted</code>: 组件已挂载</p></li></ul></li> <li><p><code>update</code>:</p> <ul><li><p>执行<code>diff</code>算法，比对改变是否需要触发 UI 更新</p></li> <li><p><code>flushScheduleQueue</code></p> <ul><li><code>watcher.before</code>: 触发<code>beforeUpdate</code>钩子 - <code>watcher.run()</code>: 执行<code>watcher</code>中的  <code>notify</code>，通知所有依赖项更新 UI</li></ul></li> <li><p>触发<code>updated</code>钩子: 组件已更新</p></li></ul></li> <li><p><code>actived / deactivated(keep-alive)</code>: 不销毁，缓存，组件激活与失活</p></li> <li><p><code>destroy</code>:</p> <ul><li><p><code>beforeDestroy</code>: 销毁开始</p></li> <li><p>销毁自身且递归销毁子组件以及事件监听</p> <ul><li><code>remove()</code>: 删除节点</li> <li><code>watcher.teardown()</code>: 清空依赖</li> <li><code>vm.$off()</code>: 解绑监听</li></ul></li> <li><p><code>destroyed</code>: 完成后触发钩子</p></li></ul></li></ul> <p>上面是<code>vue</code>的声明周期的简单梳理，接下来我们直接以代码的形式来完成<code>vue</code>的初始化</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 初始化Vue实例</span>
<span class="token keyword">function</span> <span class="token function">_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 <span class="token comment">// 挂载属性</span>
    <span class="token function">initLifeCycle</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token comment">// 初始化事件系统，钩子函数等</span>
    <span class="token function">initEvent</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token comment">// 编译slot、vnode</span>
    <span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token comment">// 触发钩子</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeCreate'</span><span class="token punctuation">)</span>
    <span class="token comment">// 添加inject功能</span>
    <span class="token function">initInjection</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token comment">// 完成数据响应性 props/data/watch/computed/methods</span>
    <span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token comment">// 添加 provide 功能</span>
    <span class="token function">initProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token comment">// 触发钩子</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'created'</span><span class="token punctuation">)</span>

	 <span class="token comment">// 挂载节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 挂载节点实现</span>
<span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 <span class="token comment">// 获取 render function</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">.</span>render<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// template to render</span>
        <span class="token comment">// Vue.compile = compileToFunctions</span>
        <span class="token keyword">let</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">compileToFunctions</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">.</span>render <span class="token operator">=</span> render
    <span class="token punctuation">}</span>
    <span class="token comment">// 触发钩子</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span><span class="token string">'beforeMount'</span><span class="token punctuation">)</span>
    <span class="token comment">// 初始化观察者</span>
    <span class="token comment">// render 渲染 vdom，</span>
    vdom <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// update: 根据 diff 出的 patchs 挂载成真实的 dom</span>
    vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vdom<span class="token punctuation">)</span>
    <span class="token comment">// 触发钩子</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'mounted'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 更新节点实现</span>
funtion <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token parameter">watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">nextTick</span><span class="token punctuation">(</span>flushScheduleQueue<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 清空队列</span>
<span class="token keyword">function</span> <span class="token function">flushScheduleQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 <span class="token comment">// 遍历队列中所有修改</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	    <span class="token comment">// beforeUpdate</span>
        watcher<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment">// 依赖局部更新节点</span>
        watcher<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">callHook</span><span class="token punctuation">(</span><span class="token string">'updated'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 销毁实例实现</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$destory</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 <span class="token comment">// 触发钩子</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeDestory'</span><span class="token punctuation">)</span>
    <span class="token comment">// 自身及子节点</span>
    <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 删除依赖</span>
    watcher<span class="token punctuation">.</span><span class="token function">teardown</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 删除监听</span>
    vm<span class="token punctuation">.</span><span class="token function">$off</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 触发钩子</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'destoryed'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="为什么组件的-data-必须是一个函数"><a href="#为什么组件的-data-必须是一个函数" class="header-anchor">#</a> 为什么组件的 data 必须是一个函数</h2> <p>每一个 vue 组件都是一个 vue 实例，通过 new Vue()实例化，引用同一个对象，如果 data 直接是一个对象的话，那么一旦修改其中一个组件的数据，其他组件相同数据就会被改变。</p> <p>而 data 是函数的话，每个 vue 组件的 data 都因为函数有了自己的作用域，每个实例可以维护一份被返回对象的独立的拷贝，互不干扰。</p> <p>理解两点：</p> <ul><li>每个组件都是 Vue 的实例。</li> <li>组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他。</li></ul> <h2 id="常见的事件修饰符及其作用"><a href="#常见的事件修饰符及其作用" class="header-anchor">#</a> 常见的事件修饰符及其作用</h2> <ul><li><code>.stop</code>：等同于 JavaScript 中的  <code>event.stopPropagation()</code> ，防止事件冒泡；</li> <li><code>.prevent</code> ：等同于 JavaScript 中的  <code>event.preventDefault()</code> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li> <li><code>.capture</code> ：与事件冒泡的方向相反，事件捕获由外到内；</li> <li><code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</li> <li><code>.once</code> ：只会触发一次。</li></ul> <h2 id="vue-extend-能做什么"><a href="#vue-extend-能做什么" class="header-anchor">#</a> Vue.extend 能做什么</h2> <p>这个 API 在独立开发组件时很有用，作用是扩展组件生成一个构造器，通常会与 $mount 一起使用。</p> <p>创建一个 Vue 实例时，都会有一个选项 el，来指定实例的根节点，如果不写 el 选项，那组件就处于未挂载状态。Vue.extend 的作用，就是基于 Vue 构造器，创建一个“子类”，它的参数跟 new Vue 的基本一样，但 data 要跟组件一样，是个函数，再配合 $mount ，就可以让组件渲染，并且挂载到任意指定的节点上，比如 body。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>app-extend<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token comment">// 创建构造器</span>
  <span class="token keyword">var</span> Profile <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">'&lt;div&gt;&lt;p&gt;{{extendData}}&lt;/p&gt;&lt;p&gt;实例传入的数据为:{{propsExtend}}&lt;/p&gt;&lt;/div&gt;'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'propsExtend'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment">// data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数</span>
    <span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">extendData</span><span class="token operator">:</span> <span class="token string">'这是extend扩展的数据'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 创建 Profile 实例，并挂载到一个元素上。</span>
  <span class="token comment">// propsData: 创建实例时传递 props(只用于 new 创建的实例中。)。主要作用是方便测试。</span>
  <span class="token keyword">new</span> <span class="token class-name">Profile</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">propsData</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">propsExtend</span><span class="token operator">:</span> <span class="token string">'我是实例传入的数据'</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app-extend'</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>实现同样的效果，除了用 extend 外，也可以直接创建 Vue 实例，并且用一个 Render 函数来渲染一个 .vue 文件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> Notification <span class="token keyword">from</span> <span class="token string">'./notification.vue'</span>

<span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 这里可以传入一些组件的 props 选项</span>

<span class="token keyword">const</span> Instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>Notification<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">props</span><span class="token operator">:</span> props
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 标准的 Vue 组件实例，因此它的 $el 属性也可以被访问：</span>
<span class="token keyword">const</span> component <span class="token operator">=</span> Instance<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>component<span class="token punctuation">.</span>$el<span class="token punctuation">)</span>
</code></pre></div><p>这样既可以使用 .vue 来写复杂的组件（毕竟在 template 里堆字符串很痛苦），还可以根据需要传入适当的 props。渲染后，如果想操作 Render 的 Notification 实例，也是很简单的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> notification <span class="token operator">=</span> Instance<span class="token punctuation">.</span>$children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
</code></pre></div><p>需要注意的是，我们是用 $mount 手动渲染的组件，如果要销毁，也要用 <code>$destroy</code> 来手动销毁实例，必要时，也可以用 removeChild 把节点从 DOM 中移除。</p> <p>据此我们可以封装一个渲染方法和卸载方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">component<span class="token punctuation">,</span> opt<span class="token punctuation">,</span> el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>component<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'亲，请传入正确的组件'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">,</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>component<span class="token punctuation">,</span> opt<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> vm
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>$el<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  vm<span class="token punctuation">.</span><span class="token function">$destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="mixin-和-mixins-区别"><a href="#mixin-和-mixins-区别" class="header-anchor">#</a> mixin 和 mixins 区别</h2> <p><code>mixin</code> 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...逻辑</span>
    <span class="token comment">// 这种方式会影响到每个组件的 beforeCreate 钩子函数</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>虽然文档不建议在应用中直接使用 <code>mixin</code>，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 <code>ajax</code> 或者一些工具函数等等。</p> <p><code>mixins</code> 应该是最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 <code>mixins</code> 混入代码，比如上拉下拉加载数据这种逻辑等等。 另外需要注意的是 <code>mixins</code> 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。</p> <h2 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="header-anchor">#</a> computed 和 watch 的区别</h2> <p>computed 是计算属性，依赖其他属性计算值，会创建新的响应式数据,并且 computed 的值有缓存，只有当计算值变化才会返回内容。</p> <p>watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</p> <p><code>watch</code>  与计算属性的区别有两个：一是计算属性依赖其他属性和有缓存，它没有；二是  <code>watch</code>  可以进行异步操作。</p> <p>为什么计算属性不能进行异步操作？因为计算属性必须将计算后的值  <code>return</code>  回去，如果在计算属性中使用异步操作，那会返回一个  <code>undefined</code>：</p> <p>所以一般来说需要依赖别的属性来动态获得值的时候可以使用 computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 watch。</p> <h2 id="vue-中的-computed-是如何实现的"><a href="#vue-中的-computed-是如何实现的" class="header-anchor">#</a> Vue 中的 computed 是如何实现的</h2> <p>主要分为四个阶段</p> <p><img src="/fe-attitude/assets/img/computed.a3ca9c78.png" alt=""></p> <ol><li><p>初始化：为 computed 属性创建 lazy watcher（此处 watcher 指双向绑定中的监听器，下同）。</p></li> <li><p>首次模板渲染：渲染 watcher 检测到 computed 属性时，会调用 computed 属性的 getter 方法，而 computed 属性的 getter 方法会调用依赖属性的 getter，从而形成链式调用，同时保存引用关系用于更新。取得计算结果后 lazy watcher 会将结果缓存，并返回给渲染 watcher 进行模板渲染。</p></li> <li><p>多次模板渲染：直接取 lazy watcher 中的缓存值给到渲染 watcher 进行渲染。</p></li> <li><p>依赖属性更新：根据首次模板渲染阶段构建的依赖关系向上通知 lazy watcher 进行重新计算，缓存计算结果并通知渲染 watcher 重新渲染更新页面。</p></li></ol> <p>computed 本身是通过代理的方式代理到组件实例上的，所以读取计算属性的时候，执行的是一个内部的 getter，而不是用户定义的方法。</p> <p>computed 内部实现了一个惰性的 watcher，在实例化的时候不会去求值，其内部通过 dirty 属性标记计算属性是否需要重新求值。当 computed 依赖的任一状态（不一定是 return 中的）发生变化，都会通知这个惰性 watcher，让它把 dirty 属性设置为 true。所以，当再次读取这个计算属性的时候，就会重新去求值。</p> <p>参考链接</p> <ul><li>https://ustbhuangyi.github.io/vue-analysis/v2/reactive/computed-watcher.html#computed</li> <li>http://febook.hzfe.org/awesome-interview/book1/frame-vue-computed-watch</li></ul> <h2 id="watch-原理"><a href="#watch-原理" class="header-anchor">#</a> watch 原理</h2> <p>watch 本质上是为每个监听属性 setter 创建了一个 watcher，当被监听的属性更新时，调用传入的回调函数。常见的配置选项有 deep 和 immediate，对应原理如下：</p> <ol><li><p>deep：深度监听对象，为对象的每一个属性创建一个 watcher，从而确保对象的每一个属性更新时都会触发传入的回调函数。主要原因在于对象属于引用类型，单个属性的更新并不会触发对象 setter，因此引入 deep 能够很好地解决监听对象的问题。同时也会引入判断机制，确保在多个属性更新时回调函数仅触发一次，避免性能浪费。</p></li> <li><p>immediate：在初始化时直接调用回调函数，可以通过在 created 阶段手动调用回调函数实现相同的效果。</p></li></ol> <h2 id="v-show-与-v-if-区别"><a href="#v-show-与-v-if-区别" class="header-anchor">#</a> v-show 与 v-if 区别</h2> <p>v-show 只是在 display: none 和 display: block 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说 v-show 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</p> <p>v-if 的话就得说到 Vue 底层的编译了（就是三元表达式呀，<code>isShow ? vNode : null</code>）。当属性初始为 false 时，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。</p> <p>并且基于 v-if 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</p> <p>参考链接：</p> <p><a href="https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show" target="_blank" rel="noopener noreferrer">https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="vue2-数组的响应性支持情况如何"><a href="#vue2-数组的响应性支持情况如何" class="header-anchor">#</a> Vue2 数组的响应性支持情况如何</h2> <p>数组的以下方法，都是可以触发视图更新的，也就是响应性的：</p> <p>push()、pop()、shift()、unshift()、splice()、sort()、reverse()。</p> <p>$set，有两种情况会用到它：</p> <ul><li>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</li></ul> <p>当利用索引直接设置一个项时，例如：this.items[index] = value; 当修改数组的长度时，例如：vm.items.length = newLength。</p> <ul><li>由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除。</li></ul> <p>还有一种小技巧，就是先 copy 一个数组，然后通过 index 修改后，再把原数组整个替换，比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">handler</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">]</span><span class="token punctuation">;</span>
  data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'x'</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>假设定义了一个数组 a=[1,2,3]，相应的，页面上显示的值为 1,2,3，现设 a[0]=5，页面上的值会变成 5,2,3 吗？为什么？</p> <p>不会</p> <p>因为 Vue 是使用  <code>Object.defineProperty</code>  来监听数值变化的，而直接修改数组的值的这种操作无法监听。</p> <p>例如：<code>vm.items[indexOfItem] = newValue</code>  这种操作是无法监听的。</p> <p>如果需要直接修改数组元素的值，可以使用  <code>Vue.set</code></p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>items<span class="token punctuation">,</span> indexOfItem<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>
</code></pre></div><p><a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener noreferrer">数组更新检测<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="组件间通信"><a href="#组件间通信" class="header-anchor">#</a> 组件间通信</h2> <p><strong>父子通信</strong></p> <ul><li>父向子传递数据是通过 props，子向父是通过 events（$emit）；</li> <li><code>v-model</code></li> <li>Vue 2.3 及以上版本的话还可以使用  <code>$listeners</code>  和  <code>.sync</code>  这两个属性</li> <li>通过父链 / 子链也可以通信（$parent / $children）；</li> <li>$refs 也可以访问组件实例；</li> <li>provide / inject API。</li></ul> <p>·.sync· 属性是个语法糖，可以很简单的实现子组件与父组件通信</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!--父组件中--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:value.sync</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token comment">&lt;!--以上写法等同于--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>v =&gt; value = v<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>comp</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!--子组件中--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'update:value'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><strong>兄弟通信</strong></p> <p>对于这种情况可以通过查找父组件中的子组件实现，也就是 this.$parent.$children，在 $children 中可以通过组件 name 查询到需要的组件实例，然后进行通信。</p> <p><strong>跨级通信</strong></p> <p>对于这种情况可以使用 Vue 2.2 新增的 API <code>provide / inject</code>。</p> <p><strong>任意组件</strong></p> <p>这种方式可以通过 Vuex 或者 Event Bus 解决。</p> <h2 id="双向绑定原理"><a href="#双向绑定原理" class="header-anchor">#</a> 双向绑定原理</h2> <p>一般使用 v-model / .sync 实现，<code>v-model</code>  是 v-bind:value 和 v-on:input 的语法糖</p> <ul><li>a. <code>v-bind:value=&quot;message&quot;</code>  实现了 data ⇒ UI 的单向绑定</li> <li>b. <code>v-on:input=&quot;message = $event.target.value&quot;</code>  实现了 UI ⇒ data 的单向绑定</li> <li>c. 加起来就是双向绑定了</li></ul> <p>这两个单向绑定是如何实现的呢？</p> <ul><li>a. 前者通过 Object.defineProperty API 给 data 创建 getter 和 setter，用于监听 data 的改变，data 一变就会安排改变 UI</li> <li>b. 后者通过 template compiler 给 DOM 添加事件监听，DOM input 的值变了就会去修改 data。</li></ul> <p>参考</p> <ul><li><a href="https://www.cnblogs.com/canfoo/p/6891868.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/canfoo/p/6891868.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="自定义组件的语法糖-v-model-是怎样实现的"><a href="#自定义组件的语法糖-v-model-是怎样实现的" class="header-anchor">#</a> 自定义组件的语法糖 v-model 是怎样实现的</h2> <p>v-model 是一个语法糖，可以拆解为 props: value 和 events: input。就是说组件必须提供一个名为 value 的 prop，以及名为 input 的自定义事件</p> <p>这个组件中，只有一个 props，但是名字叫 value，内部还有一个 currentValue，当改变 currentValue 时，会触发一个自定义事件 @input，并把 currentValue 的值返回。这就是一个 v-model 的语法糖，它要求 props 有一个叫 value 的项，同时触发的自定义事件必须叫 input。这样就可以在自定义组件上用 v-model 了：</p> <p>props 一般不能在组件内修改，它是通过父级修改的，因此实现 v-model 一般都会有一个 currentValue 的内部 data，初始时从 value 获取一次值，当 value 修改时，也通过 watch 监听到及时更新；组件不会修改 value 的值，而是修改 currentValue，同时将修改的值通过自定义事件 input 派发给父组件，父组件接收到后，由父组件修改 value。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>custom-component</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>custom-component</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>message<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>message = $event.targer.value<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
`
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    {{ currentValue }}
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>handleClick<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Click<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">type</span><span class="token operator">:</span> Number<span class="token punctuation">,</span>
        <span class="token keyword">default</span><span class="token operator">:</span> <span class="token number">0</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">currentValue</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>currentValue <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>currentValue<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">value</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>currentValue <span class="token operator">=</span> val
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="keep-alive-有什么作用"><a href="#keep-alive-有什么作用" class="header-anchor">#</a> keep-alive 有什么作用</h2> <p><code>keep-alive</code>  可以使被包含的组件保留状态，或避免重新渲染。在  <code>Vue</code>  中，每次切换组件时，都会重新渲染。如果有多个组件切换，又想让它们保持原来的状态，避免重新渲染，这个时候就可以使用  <code>keep-alive</code>。</p> <p>对于 keep-alive 组件来说，它拥有两个独有的生命周期钩子函数，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 activated 缓存激活钩子函数，缓存失活后会执行 deactivated 钩子函数。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 失活的组件将会被缓存！--&gt;</span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>currentTabComponent<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>keep-alive 有以下三个属性：</p> <ul><li>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li> <li>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li> <li>max 数字，最多可以缓存多少组件实例。</li></ul> <p>注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。</p> <p>主要流程</p> <ol><li>判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li> <li>获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li> <li>key 生成规则，cid +&quot;∶∶&quot;+ tag ，仅靠 cid 是不够的，因为相同的构造函数可以注册为不同的本地组件。</li> <li>如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。</li> <li>最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li></ol> <ul><li><a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%9C%A8%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-keep-alive" target="_blank" rel="noopener noreferrer">https://cn.vuejs.org/v2/guide/components-dynamic-async.html#在动态组件上使用-keep-alive<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="vue-keep-alive-组件原理详解"><a href="#vue-keep-alive-组件原理详解" class="header-anchor">#</a> Vue <code>keep-alive</code> 组件原理详解</h2> <p><code>keep-alive</code> 是 Vue 的内置组件，用于 <strong>缓存组件实例</strong>，避免重复渲染和销毁。以下是其核心原理的分步解析：</p> <hr> <h4 id="一、核心作用"><a href="#一、核心作用" class="header-anchor">#</a> <strong>一、核心作用</strong></h4> <ol><li><strong>状态保留</strong>：保留被包裹组件的状态（如数据、DOM 结构）</li> <li><strong>性能优化</strong>：避免重复执行以下操作：
<ul><li>组件销毁 (<code>beforeDestroy/destroyed</code>)</li> <li>重新创建实例 (<code>created/mounted</code>)</li></ul></li> <li><strong>生命周期管理</strong>：触发特有的 <code>activated/deactivated</code> 钩子</li></ol> <hr> <h4 id="二、实现原理"><a href="#二、实现原理" class="header-anchor">#</a> <strong>二、实现原理</strong></h4> <p><strong>1. 缓存机制</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 伪代码示例</span>
<span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 使用缓存对象存储组件实例</span>

<span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token function">getComponentKey</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> cachedComponent <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>cachedComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 从缓存恢复实例</span>
    <span class="token keyword">return</span> cachedComponent<span class="token punctuation">.</span>componentInstance
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建新实例并缓存</span>
    <span class="token keyword">const</span> component <span class="token operator">=</span> <span class="token function">createComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    cache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> component<span class="token punctuation">)</span>
    <span class="token keyword">return</span> component
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>2. 键值生成</strong></p> <ul><li>默认使用组件 <code>name</code> + <code>tag</code> 生成唯一标识</li> <li>可通过 <code>include/exclude</code> 过滤组件</li> <li><code>max</code> 属性控制最大缓存数量（LRU 淘汰策略）</li></ul> <p><strong>3. 生命周期管理</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 组件激活时</span>
<span class="token keyword">function</span> <span class="token function">activated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 恢复滚动位置</span>
  <span class="token comment">// 重新触发某些副作用（如定时器）</span>
<span class="token punctuation">}</span>

<span class="token comment">// 组件停用时</span>
<span class="token keyword">function</span> <span class="token function">deactivated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 保存滚动位置</span>
  <span class="token comment">// 暂停副作用</span>
<span class="token punctuation">}</span>
</code></pre></div><hr> <h4 id="三、工作流程"><a href="#三、工作流程" class="header-anchor">#</a> <strong>三、工作流程</strong></h4> <div class="language-mermaid extra-class"><pre class="language-mermaid"><code><span class="token keyword">graph</span> TD
  A<span class="token text string">[组件首次渲染]</span> <span class="token arrow operator">--&gt;</span><span class="token label property">|创建实例|</span> B<span class="token text string">[缓存实例]</span>
  B <span class="token arrow operator">--&gt;</span> C<span class="token text string">[返回实例]</span>
  D<span class="token text string">[组件再次进入]</span> <span class="token arrow operator">--&gt;</span><span class="token label property">|匹配缓存|</span> E<span class="token text string">[直接复用实例]</span>
  E <span class="token arrow operator">--&gt;</span> F<span class="token text string">[触发 activated 钩子]</span>
  G<span class="token text string">[超出 max 限制]</span> <span class="token arrow operator">--&gt;</span> H<span class="token text string">[淘汰最久未使用的实例]</span>
</code></pre></div><hr> <h4 id="四、源码关键点分析"><a href="#四、源码关键点分析" class="header-anchor">#</a> <strong>四、源码关键点分析</strong></h4> <ol><li><p><strong><code>render</code> 方法</strong> (<a href="https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js" target="_blank" rel="noopener noreferrer">源码位置<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token function">getFirstComponentChild</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$slots<span class="token punctuation">.</span>default<span class="token punctuation">)</span>
  <span class="token keyword">const</span> key <span class="token operator">=</span> vnode<span class="token punctuation">.</span>key <span class="token operator">??</span> <span class="token function">getComponentKey</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>componentInstance
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> vnode
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> vnode
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><strong>LRU 缓存淘汰</strong> (当超过 <code>max</code> 时)</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>max <span class="token operator">&amp;&amp;</span> keys<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>max<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">pruneCacheEntry</span><span class="token punctuation">(</span>cache<span class="token punctuation">,</span> keys<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> keys<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_vnode<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol> <hr> <h4 id="五、使用场景"><a href="#五、使用场景" class="header-anchor">#</a> <strong>五、使用场景</strong></h4> <table><thead><tr><th>场景</th> <th>优势</th></tr></thead> <tbody><tr><td>标签页切换</td> <td>保留表单数据</td></tr> <tr><td>列表详情页</td> <td>保持滚动位置</td></tr> <tr><td>复杂组件切换</td> <td>提升渲染性能</td></tr></tbody></table> <hr> <h4 id="六、注意事项"><a href="#六、注意事项" class="header-anchor">#</a> <strong>六、注意事项</strong></h4> <ol><li><strong>必须设置组件 <code>name</code></strong>：否则无法正确缓存</li> <li><strong>避免动态组件滥用</strong>：不需要缓存的组件不要包裹</li> <li><strong>内存管理</strong>：合理设置 <code>max</code> 属性</li> <li><strong>不适用场景</strong>：频繁更新数据的组件可能反而降低性能</li></ol> <hr> <h4 id="七、调试技巧"><a href="#七、调试技巧" class="header-anchor">#</a> <strong>七、调试技巧</strong></h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 查看当前缓存实例</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>keepAliveRef<span class="token punctuation">.</span>cache<span class="token punctuation">)</span>

<span class="token comment">// 强制清除缓存</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>keepAliveRef<span class="token punctuation">.</span><span class="token function">pruneCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="如何强制刷新-vue-组件"><a href="#如何强制刷新-vue-组件" class="header-anchor">#</a> 如何强制刷新 Vue 组件</h2> <ul><li>使用 key</li> <li>使用 this.$forceUpdate</li> <li>使用 v-if</li> <li>刷新当前页面</li></ul> <h2 id="vue-为何是异步渲染"><a href="#vue-为何是异步渲染" class="header-anchor">#</a> Vue 为何是异步渲染</h2> <p>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。</p> <p>例如，当你设置 vm.someData = 'new value'，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。例如：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>example<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#example'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">'123'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
vm<span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">'new message'</span> <span class="token comment">// 更改数据</span>
vm<span class="token punctuation">.</span>$el<span class="token punctuation">.</span>textContent <span class="token operator">===</span> <span class="token string">'new message'</span> <span class="token comment">// false</span>
Vue<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>$el<span class="token punctuation">.</span>textContent <span class="token operator">===</span> <span class="token string">'new message'</span> <span class="token comment">// true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>参考链接</p> <ul><li><a href="https://juejin.cn/post/6844903591052836878" target="_blank" rel="noopener noreferrer">为什么 Vue 使用异步更新队列？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97" target="_blank" rel="noopener noreferrer">https://cn.vuejs.org/v2/guide/reactivity.html#异步更新队列<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="nexttick"><a href="#nexttick" class="header-anchor">#</a> nextTick</h2> <p>nextTick 是 Vue.js 提供的一个函数，并非浏览器内置。nextTick 函数接收一个回调函数 cb，在下一个 DOM 更新循环之后执行。比如下面的示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">show</span><span class="token operator">:</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">handleShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token boolean">true</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>node<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>node<span class="token punctuation">)</span> <span class="token comment">// &lt;p&gt;内容&lt;/p&gt;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在下次 dom 更新循环结束之后执行延迟回调，可用于获取更新后的 dom 状态</p> <ul><li><p>新版本中默认是 microtasks, v-on 中会使用 macrotasks</p></li> <li><p>macrotasks 任务的实现:</p> <ul><li>setImmediate / MessageChannel / setTimeout</li></ul></li></ul> <p>另一个例子，当我们按下 click 按钮的时候，number 会被循环增加 1000 次。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{ number }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>handleClick<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>click<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">number</span><span class="token operator">:</span> <span class="token number">0</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>number<span class="token operator">++</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在这个例子中， <code>number</code>  会被不停地进行  <code>++</code>  操作，不断地触发它对应的  <code>Dep</code>  中的  <code>Watcher</code>  对象的  <code>update</code>  方法。然后最终  <code>queue</code>  中因为对相同  <code>id</code>  的  <code>Watcher</code>  对象进行了筛选，从而  <code>queue</code>  中实际上只会存在一个  <code>number</code>  对应的  <code>Watcher</code>  对象。在下一个 tick 的时候（此时  <code>number</code>  已经变成了 1000），触发  <code>Watcher</code>  对象的  <code>run</code>  方法来更新视图，将视图上的  <code>number</code>  从 0 直接变成 1000。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> uid <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token operator">++</span>uid
  <span class="token punctuation">}</span>

  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'watch'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">+</span> <span class="token string">' update'</span><span class="token punctuation">)</span>
    <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'watch'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">+</span> <span class="token string">'视图更新啦～'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> has <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> waiting <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token keyword">let</span> callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> pending <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token keyword">function</span> <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token parameter">watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> id <span class="token operator">=</span> watcher<span class="token punctuation">.</span>id
  <span class="token keyword">if</span> <span class="token punctuation">(</span>has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>waiting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      waiting <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token comment">// 执行完成再恢复 waiting flag</span>
      <span class="token function">nextTick</span><span class="token punctuation">(</span>flushSchedulerQueue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">flushSchedulerQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> watcher<span class="token punctuation">,</span> id
  <span class="token keyword">for</span> <span class="token punctuation">(</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    watcher <span class="token operator">=</span> queue<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
    id <span class="token operator">=</span> watcher<span class="token punctuation">.</span>id
    has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span>
    watcher<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  waiting <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pending <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">flushCallbacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  pending <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token keyword">const</span> copies <span class="token operator">=</span> callbacks<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  callbacks<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> copies<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    copies<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="vue-事件绑定原理说一下"><a href="#vue-事件绑定原理说一下" class="header-anchor">#</a> Vue 事件绑定原理说一下</h2> <p>每一个 Vue 实例都是一个 Event Bus，当子组件被创建的时候，父组件将事件传递给子组件，子组件初始化的时候是有$on方法将事件注册到内部，在需要的时候使用$emit 触发函数，而对于原生 native 事件，使用 addEventListener 绑定到真实的 DOM 元素上。</p> <h2 id="slot-是什么-有什么作用-原理是什么"><a href="#slot-是什么-有什么作用-原理是什么" class="header-anchor">#</a> slot 是什么？有什么作用？原理是什么？</h2> <p>slot 又名插槽，是 Vue 的内容分发机制，组件内部的模板引擎使用 slot 元素作为承载分发内容的出口。插槽 slot 是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。</p> <p>slot 又分三类，默认插槽，具名插槽和作用域插槽。</p> <ul><li>默认插槽：又名匿名插槽，当 slot 没有指定 name 属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li> <li>具名插槽：带有具体名字的插槽，也就是带有 name 属性的 slot，一个组件可以出现多个具名插槽。</li> <li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li></ul> <p>实现原理：当子组件 vm 实例化时，获取到父组件传入的 slot 标签的内容，存放在 vm.$slot中，默认插槽为vm.$slot.default，具名插槽为 vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot 中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p> <h2 id="vue-模板渲染的原理是什么"><a href="#vue-模板渲染的原理是什么" class="header-anchor">#</a> Vue 模板渲染的原理是什么？</h2> <p>vue 中的模板 template 无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的 HTML 语法，所有需要将 template 转化成一个 JavaScript 函数，这样浏览器就可以执行这一个函数并渲染出对应的 HTML 元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。</p> <p>模板编译又分三个阶段，解析 parse，优化 optimize，生成 generate，最终生成可执行函数 render。</p> <ul><li>parse 阶段：使用大量的正则表达式对 template 字符串进行解析，将标签、指令、属性等转化为抽象语法树 AST。</li> <li>optimize 阶段：遍历 AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行 diff 比较时，直接跳过这一些静态节点，优化 runtime 的性能。</li> <li>generate 阶段：将最终的 AST 转化为 render 函数字符串。</li></ul> <h2 id="template-预编译是什么"><a href="#template-预编译是什么" class="header-anchor">#</a> template 预编译是什么？</h2> <p>对于 Vue 组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后在也不会进行编译。因此，编译对组件的 runtime 是一种性能损耗。</p> <p>而模板编译的目的仅仅是将 template 转化为 render function，这个过程，正好可以在项目构建的过程中完成，这样可以让实际组件在 runtime 时直接跳过模板渲染，进而提升性能，这个在项目构建的编译 template 的过程，就是预编译。</p> <h2 id="那-template-和-jsx-的有什么分别"><a href="#那-template-和-jsx-的有什么分别" class="header-anchor">#</a> 那 template 和 jsx 的有什么分别？</h2> <p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而我们有了预编译之后，我们只需要保证构建过程中生成 render 函数就可以。</p> <p>在 webpack 中，我们使用 vue-loader 编译.vue 文件，内部依赖的 vue-template-compiler 模块，在 webpack 构建过程中，将 template 预编译成 render 函数。</p> <p>与 react 类似，在添加了 jsx 的语法糖解析器 babel-plugin-transform-vue-jsx 之后，就可以直接手写 render 函数。</p> <p>所以，template 和 jsx 的都是 render 的一种表现形式，不同的是：</p> <p>JSX 相对于 template 而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p> <h2 id="virtual-dom"><a href="#virtual-dom" class="header-anchor">#</a> Virtual DOM</h2> <p>Virtual DOM 是 DOM 节点在 JavaScript 中的一种抽象数据结构，之所以需要虚拟 DOM，是因为浏览器中操作 DOM 的代价比较昂贵，频繁操作 DOM 会产生性能问题。虚拟 DOM 的作用是在每一次响应式数据发生变化引起页面重渲染时，Vue 对比更新前后的虚拟 DOM，匹配找出尽可能少的需要更新的真实 DOM，从而达到提升性能的目的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> ul <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">'ul'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'list'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">'1'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上述代码对应的 DOM 就是</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>ul <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;list&quot;</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
</code></pre></div><p>那么既然 DOM 可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM。当然了，通过 JS 来模拟 DOM 并且渲染对应的 DOM 只是第一步，难点在于如何判断新旧两个 JS 对象的<strong>最小差异</strong>并且实现<strong>局部更新</strong> DOM。</p> <p>首先 DOM 是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。 实现 O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。 所以判断差异的算法就分为了两步</p> <ul><li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异</li> <li>一旦节点有子元素，就去判断子元素是否有不同</li></ul> <p>在第一步算法中我们需要判断新旧节点的  <code>tagName</code>  是否相同，如果不相同的话就代表节点被替换了。如果没有更改  <code>tagName</code>  的话，就需要判断是否有子元素，有的话就进行第二步算法。</p> <p>在第二步算法中，我们需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动。</p> <p>举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更</p> <div class="language- extra-class"><pre class="language-text"><code>// 假设这里模拟一个 ul，其中包含了 5 个 li
[1, 2, 3, 4, 5]
// 这里替换上面的 li
[1, 2, 5, 4]
</code></pre></div><p>从上述例子中，我们一眼就可以看出先前的  <code>ul</code>  中的第三个  <code>li</code>  被移除了，四五替换了位置。</p> <p>那么在实际的算法中，我们如何去识别改动的是哪个节点呢？这就引入了  <code>key</code>  这个属性，想必大家在 Vue 或者 React 的列表中都用过这个属性。这个属性是用来给每一个节点打标志的，用于判断是否是同一个节点。</p> <p>当然在判断以上差异的过程中，我们还需要判断节点的属性是否有变化等等。</p> <p>当我们判断出以上的差异后，就可以把这些差异记录下来。当对比完两棵树以后，就可以通过差异去局部更新 DOM，实现性能的最优化。</p> <p>当然了 Virtual DOM 提高性能是其中一个优势，其实<strong>最大的优势</strong>还是在于：</p> <ol><li>将 Virtual DOM 作为一个兼容层，让我们还能对接非 Web 端的系统，实现跨端开发。</li> <li>同样的，通过 Virtual DOM 我们可以渲染到其他的平台，比如实现 SSR、同构渲染等等。</li> <li>实现组件的高度抽象化</li></ol> <p><a href="https://www.zhihu.com/question/29504639" target="_blank" rel="noopener noreferrer">如何理解虚拟 DOM?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="介绍一下-vue-中的-diff-算法"><a href="#介绍一下-vue-中的-diff-算法" class="header-anchor">#</a> 介绍一下 Vue 中的 Diff 算法</h2> <p>在新老虚拟 DOM 对比时</p> <ul><li>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换</li> <li>如果为相同节点，进行 patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除)</li> <li>比较如果都有子节点，则进行 updateChildren，判断如何对这些新老节点的子节点进行操作（diff 核心）。</li> <li>匹配时，找到相同的子节点，递归比较子节点</li> <li>同一层级的一组节点，可以通过唯一标识符进行区分</li></ul> <p>在 diff 中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从 O(n^3)降低值 O(n)，也就是说，只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。</p> <p>Vue 的 Diff 算法和 React 的类似，只在同一层次进行比较，不进行跨层比较。如果两个元素被判定为不相同，则不继续递归比较。在 Diff 子元素的过程中，采用双端比较的方法，设立 4 个指针：</p> <ul><li>oldStartIdx 指向旧子元素列表中，从左边开始 Diff 的元素索引。初始值：第一个元素的索引。</li> <li>newStartIdx 指向新子元素列表中，从左边开始 Diff 的元素索引。初始值：第一个元素的索引。</li> <li>oldEndIdx 指向旧子元素列表中，从右边开始 Diff 的元素索引。初始值：最后一个元素的索引。</li> <li>newEndIdx 指向新子元素列表中，从右边开始 Diff 的元素索引。初始值：最后一个元素的索引。</li></ul> <p><img src="/fe-attitude/assets/img/vue-diff.bf2c6315.png" alt=""></p> <p>Vue 同时遍历新老子元素虚拟 DOM 列表，并采用头尾比较。一般有 4 种情况：</p> <ol><li><strong>当新老 start 指针指向的是相同节点</strong></li></ol> <p>复用节点并按需更新。</p> <p>新老 start 指针向右移动一位。</p> <ol start="2"><li><strong>当新老 end 指针指向的是相同节点</strong></li></ol> <p>复用节点并按需更新。</p> <p>新老 end 指针向左移动一位。</p> <ol start="3"><li><strong>当老 start 指针和新 end 指针指向的是相同节点</strong></li></ol> <p>复用节点并按需更新，将节点对应的真实 DOM 移动到子元素列表队尾。</p> <p>老 start 指针向右移动一位。</p> <p>新 end 指针向左移动一位。</p> <ol start="4"><li><strong>当老 end 指针和新 start 指针指向的是相同节点</strong></li></ol> <p>复用节点并按需更新，将节点对应的真实 DOM 移动到子元素列表队头。</p> <p>老 end 指针向左移动一位。</p> <p>新 start 指针向右移动一位。</p> <p>在不满足以上情况的前提下，会尝试检查新 start 指针指向的节点是否有唯一标识符 key，如果有且能在旧列表中找到拥有相同 key 的相同类型节点，则可复用并按需更新，且移动节点到新的位置。新 start 指针向右移动一位。如果依旧不满足条件，则新增相关节点。</p> <p>当新老列表的中任意一个列表的头指针索引大于尾指针索引时，循环遍历结束，按需删除或新增相关节点即可。</p> <h2 id="vue-中-key-的作用"><a href="#vue-中-key-的作用" class="header-anchor">#</a> Vue 中 key 的作用</h2> <p>vue 中 key 值的作用可以分为两种情况来考虑：</p> <ul><li>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</li> <li>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</li></ul> <p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速</p> <ol><li>更准确</li></ol> <p>因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。</p> <ol start="2"><li>更快速</li></ol> <p>利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</p> <p>vue 部分源码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// vue项目  src/core/vdom/patch.js  -488行</span>
<span class="token comment">// 以下是为了阅读性进行格式化后的代码</span>

<span class="token comment">// oldCh 是一个旧虚拟节点数组</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>oldKeyToIdx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  oldKeyToIdx <span class="token operator">=</span> <span class="token function">createKeyToOldIdx</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">,</span> oldStartIdx<span class="token punctuation">,</span> oldEndIdx<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// map 方式获取</span>
  idxInOld <span class="token operator">=</span> oldKeyToIdx<span class="token punctuation">[</span>newStartVnode<span class="token punctuation">.</span>key<span class="token punctuation">]</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 遍历方式获取</span>
  idxInOld <span class="token operator">=</span> <span class="token function">findIdxInOld</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> oldStartIdx<span class="token punctuation">,</span> oldEndIdx<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>创建 map 函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createKeyToOldIdx</span><span class="token punctuation">(</span><span class="token parameter">children<span class="token punctuation">,</span> beginIdx<span class="token punctuation">,</span> endIdx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i<span class="token punctuation">,</span> key
  <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> beginIdx<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> endIdx<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    key <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> map<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> map
<span class="token punctuation">}</span>
</code></pre></div><p>遍历寻找</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// sameVnode 是对比新旧节点是否相同的函数</span>
<span class="token keyword">function</span> <span class="token function">findIdxInOld</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> c <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sameVnode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="vue-怎么实现页面的权限控制"><a href="#vue-怎么实现页面的权限控制" class="header-anchor">#</a> vue 怎么实现页面的权限控制</h2> <p>利用  <code>vue-router</code>  的  <code>beforeEach</code>  事件，可以在跳转页面前判断用户的权限（利用 cookie 或 token），是否能够进入此页面，如果不能则提示错误或重定向到其他页面，在后台管理系统中这种场景经常能遇到。</p> <h2 id="vue-router-基础"><a href="#vue-router-基础" class="header-anchor">#</a> vue-router 基础</h2> <p>Vue Router 是 Vue.js 的官方路由。</p> <ul><li>mode
<ul><li>hash</li> <li>history</li></ul></li> <li>跳转
<ul><li>this.$router.push()</li></ul></li> <li>占位</li> <li>常用 this.$router.push/this.$router.replace/this.$route.params</li> <li>导航守卫
<ul><li>追加子路由 addRoute</li> <li>前置 beforeEach</li> <li>后置 afterEach</li></ul></li> <li>懒加载
<ul><li><code>const List = () =&gt; import('@/components/list.vue')</code></li></ul></li></ul> <p>Hash 模式和 History 模式的区别：</p> <ul><li>一个用的 Hash，一个用的 History API</li> <li>一个不需要后端 nginx 配合，一个需要</li></ul> <h2 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="header-anchor">#</a> $route 和$router 的区别</h2> <p>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p> <h2 id="路由原理"><a href="#路由原理" class="header-anchor">#</a> 路由原理</h2> <p>前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式</p> <ul><li>Hash 模式</li> <li>History 模式</li></ul> <p><strong>Hash 模式</strong></p> <p><code>www.test.com/#/</code>  就是 Hash URL，当 # 后面的哈希值发生变化时，可以通过  <code>hashchange</code>  事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是  <code>www.test.com</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'hashchange'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 具体逻辑</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>Hash 模式相对来说更简单，并且兼容性也更好。</p> <p><strong>History 模式</strong></p> <p>History 模式是 HTML5 新推出的功能，主要使用  <code>history.pushState</code>  和  <code>history.replaceState</code>  改变 URL。</p> <p>通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 新增历史记录</span>
history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span>stateObject<span class="token punctuation">,</span> title<span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">)</span>
<span class="token comment">// 替换当前历史记录</span>
history<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span>stateObject<span class="token punctuation">,</span> title<span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">)</span>
当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件

window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'popstate'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
<span class="token comment">// e.state 就是 pushState(stateObject) 中的 stateObject</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>state<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>两种模式对比</strong></p> <ul><li>Hash 模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL</li> <li>History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串</li> <li>Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候</li></ul> <blockquote><p>拓展：<a href="https://juejin.im/post/6844903589123457031" target="_blank" rel="noopener noreferrer">面试官: 你了解前端路由吗?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p></blockquote> <h2 id="vuex-基础"><a href="#vuex-基础" class="header-anchor">#</a> vuex 基础</h2> <p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。</p> <ul><li>state： 状态中心</li> <li>mutations: 更改状态</li> <li>actions: 异步更改状态，通知 mutations</li> <li>getters: 获取状态</li> <li>modules: 将 state 分成多个 modules，便于管理</li></ul> <p>Vuex 中 mutations 和 actions 的区别</p> <p>主要的区别是，actions 可以执行异步。actions 是调用 mutations，而 mutations 来修改 store。</p> <ul><li>同步 —— 触发 mutations：store.commit('increment')</li> <li>异步 —— 触发 dispatch： dispatch 触发 actions 定义的方法 -&gt; commit 触发 mutations 定义的方法 -&gt; store.state -&gt; render</li></ul> <p>辅助函数 mapState, mapMutations</p> <h2 id="为什么-vuex-的-mutation-中不能做异步操作"><a href="#为什么-vuex-的-mutation-中不能做异步操作" class="header-anchor">#</a> 为什么 Vuex 的 mutation 中不能做异步操作？</h2> <ul><li>Vuex 中所有的状态更新的唯一途径都是 mutation，异步操作通过 Action 来提交 mutation 实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li> <li>每个 mutation 执行完成后都会对应到一个新的状态变更，这样 devtools 就可以打个快照存下来，然后就可以实现 time-travel 了。如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</li></ul> <h2 id="vuex-原理"><a href="#vuex-原理" class="header-anchor">#</a> vuex 原理</h2> <p>vuex 的原理其实非常简单，它为什么能实现所有的组件共享同一份数据？<br>
因为 vuex 生成了一个 store 实例，并且把这个实例挂在了所有的组件上，所有的组件引用的都是同一个 store 实例。<br>
store 实例上有数据，有方法，方法改变的都是 store 实例上的数据。由于其他组件引用的是同样的实例，所以一个组件改变了 store 上的数据， 导致另一个组件上的数据也会改变，就像是一个对象的引用。</p> <blockquote><p>拓展: 模拟 vue 轮子对应的<a href="https://github.com/woai3c/mini-vuex/blob/master/mini-vuex.js" target="_blank" rel="noopener noreferrer">vuex 插件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。它实现了除 vuex 模块外的所有功能。</p></blockquote> <h2 id="vue-和-react-之间的区别"><a href="#vue-和-react-之间的区别" class="header-anchor">#</a> Vue 和 React 之间的区别</h2> <p>Vue 的表单可以使用  <code>v-model</code>  支持双向绑定，相比于 React 来说开发上更加方便，当然了  <code>v-model</code>  其实就是个语法糖，本质上和 React 写表单的方式没什么区别。</p> <p>改变数据方式不同，Vue 修改状态相比来说要简单许多，React 需要使用  <code>setState</code>  来改变状态，并且使用这个 API 也有一些坑点。并且 Vue 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 React 还是需要用户手动去优化这方面的问题。</p> <p>React 16 以后，有些钩子函数会执行多次，这是因为引入 Fiber 的原因。</p> <p>React 需要使用 JSX，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 JS 来控制页面，更加的灵活。Vue 使用了模板语法，相比于 JSX 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写  <code>render</code>  函数就能在浏览器中运行。</p> <p>在生态上来说，两者其实没多大的差距，当然 React 的用户是远远高于 Vue 的。</p> <p>在上手成本上来说，Vue 一开始的定位就是尽可能的降低前端开发的门槛，然而 React 更多的是去改变用户去接受它的概念和思想，相较于 Vue 来说上手成本略高。</p> <h2 id="vue-3-对比-vue-2-做了哪些改动"><a href="#vue-3-对比-vue-2-做了哪些改动" class="header-anchor">#</a> Vue 3 对比 Vue 2 做了哪些改动？</h2> <ol><li>重构响应式系统，使用 Proxy 替换 Object.defineProperty，使用 Proxy 优势：</li></ol> <ul><li>可直接监听数组类型的数据变化</li> <li>监听的目标为对象本身，不需要像 Object.defineProperty 一样遍历每个属性，有一定的性能提升</li> <li>可拦截 apply、ownKeys、has 等 13 种方法，而 Object.defineProperty 不行</li> <li>直接实现对象属性的新增/删除</li></ul> <ol start="2"><li>新增 Composition API，更好的逻辑复用和代码组织</li> <li>重构 Virtual DOM</li></ol> <ul><li>模板编译时的优化，将一些静态节点编译成常量</li> <li>slot 优化，将 slot 编译为 lazy 函数，将 slot 的渲染的决定权交给子组件</li> <li>模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）</li></ul> <ol start="4"><li>代码结构调整，更便于 Tree shaking，使得体积更小</li></ol> <ul><li>全局 Vue API 已更改为使用应用程序实例: new Vue() =&gt; createApp()</li> <li>全局和内部 API 已经被重构为支持 tree-shake</li></ul> <ol start="5"><li>使用 Typescript 替换 Flow</li> <li>其他特性</li></ol> <ul><li>v-model 代替了以前的 v-model 和 .sync</li> <li>在同一元素上使用的 v-if 和 v-for 优先级已更改</li> <li>根元素可以有不止一个元素了</li> <li>新增 Teleport 传送门</li> <li>destroyed 被改名为 unmounted 了（before 当然也改了）</li> <li>渲染函数 API h</li></ul> <blockquote><p><a href="https://v3.cn.vuejs.org/guide/migration/introduction.html#%E9%9D%9E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8F%98%E6%9B%B4" target="_blank" rel="noopener noreferrer">非兼容的变更<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="proxy-相比于-defineproperty-的优势"><a href="#proxy-相比于-defineproperty-的优势" class="header-anchor">#</a> Proxy 相比于 defineProperty 的优势</h2> <ul><li>数组变化也能监听到，不需要劫持改变原数组的方法，也支持通过索引对数组进行修改。</li> <li>动态创建的 data 属性不再需要用 Vue.set 来赋值</li> <li>defineProperty 需要提前递归地遍历 data 做到响应式，而 Proxy 可以在真正用到 深层数据的时候再做响应式（惰性, 可以代理动态增加的属性）</li> <li>更多的监听方法</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Object.defineProperty</span>
<span class="token keyword">function</span> <span class="token function">observer</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//针对value是对象，递归检测</span>
  <span class="token function">observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token comment">//劫持对象的key</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'获取：'</span> <span class="token operator">+</span> key<span class="token punctuation">)</span>
      <span class="token keyword">return</span> value
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//针对所设置的val是对象</span>
      <span class="token function">observer</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">'-数据改变了'</span><span class="token punctuation">)</span>
      value <span class="token operator">=</span> val
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'yanyue404'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">flag</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">book</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'js'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">page</span><span class="token operator">:</span> <span class="token number">325</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">like</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'吃饭'</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">observer</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>

<span class="token comment">// 1. 新增一个属性，由于在 执行 observer(obj) 的时候没有这个属性，所以无法监听到，删除的属性页无法监听到。</span>
<span class="token comment">// 2. 数组的变化无法监听到 (! 数组属性实际修改成功， push， splice，pop)</span>
<span class="token comment">// 3. 递归遍历对象，使用 Object.defineProperty 劫持对象属性，如果遍历的对象很深，花费的时间比较久，甚至性能问题</span>

<span class="token keyword">function</span> <span class="token function">observerProxy</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'正在读取'</span><span class="token punctuation">,</span> prop<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span> <span class="token comment">// 将操作转发给对象</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'正在写入'</span><span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span> <span class="token comment">// 将操作转发给对象</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> prop</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'正在删除'</span><span class="token punctuation">,</span> prop<span class="token punctuation">)</span>
      <span class="token keyword">delete</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'yanyue404'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">flag</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">book</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'js'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">page</span><span class="token operator">:</span> <span class="token number">325</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">like</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'吃饭'</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token function">observerProxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
<span class="token comment">// 拦截方式除了 get、set、deleteProperty 还有很多监听方法，</span>
<span class="token comment">// 也可以兼容 Object.defineProperty 监听不到的操作，如 监听数组（对数组进行push shift 等操作，会触发对应的方法名称和 length 变化），监听对象属性的新增、删除等</span>

<span class="token comment">// 使用场景</span>
<span class="token comment">// 1. 负索引数组</span>
<span class="token comment">// 2. 表单校验</span>
<span class="token comment">// 3. 增加附加属性</span>
<span class="token comment">// 4. 数据格式化</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> target <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'正在读取'</span><span class="token punctuation">,</span> prop<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prop <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> target<span class="token punctuation">[</span>target<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token operator">-</span>prop<span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceError</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Property doesn't exist: &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prop<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'正在写入'</span><span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span> <span class="token comment">// 将操作转发给对象</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">MDN Proxy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://zh.javascript.info/proxy" target="_blank" rel="noopener noreferrer">https://zh.javascript.info/proxy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="vue-3-为什么使用-composition-api"><a href="#vue-3-为什么使用-composition-api" class="header-anchor">#</a> Vue 3 为什么使用 Composition API？</h2> <p>Vue2.0 中，随着功能的增加，组件变得越来越复杂，越来越难维护，而难以维护的根本原因是 Vue 的 API 设计迫使开发者使用 watch，computed，methods 选项组织代码，而不是实际的业务逻辑。</p> <p>另外 Vue2.0 缺少一种较为简洁的低成本的机制来完成逻辑复用，虽然可以 minxis 完成逻辑复用，但是当 mixin 变多的时候，会使得难以找到对应的 data、computed 或者 method 来源于哪个 mixin，使得类型推断难以进行。</p> <p>所以 Composition API 的出现，主要是也是为了解决 Option API 带来的问题。</p> <p>第一个是代码组织问题，Compostion API 可以让开发者根据业务逻辑组织自己的代码，让代码具备更好的可读性和可扩展性，也就是说当下一个开发者接触这一段不是他自己写的代码时，他可以更好的利用代码的组织反推出实际的业务逻辑，或者根据业务逻辑更好的理解代码。</p> <p>第二个是实现代码的逻辑提取与复用，当然 mixin 也可以实现逻辑提取与复用，但是像前面所说的，多个 mixin 作用在同一个组件时，很难看出 property 是来源于哪个 mixin，来源不清楚，另外，多个 mixin 的 property 存在变量命名冲突的风险。而 Composition API 刚好解决了这两个问题。</p> <p>第三个更适合 TypeScript。</p> <p>参考</p> <ul><li><a href="https://zhuanlan.zhihu.com/p/68477600" target="_blank" rel="noopener noreferrer">尤雨溪的博客：Vue Function-based API RFC<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="vue-cli4、vue-cli43、vue-cli2-的区别"><a href="#vue-cli4、vue-cli43、vue-cli2-的区别" class="header-anchor">#</a> vue-cli4、vue-cli43、vue-cli2 的区别</h2> <ul><li><a href="https://cli.vuejs.org/zh/guide/" target="_blank" rel="noopener noreferrer">https://cli.vuejs.org/zh/guide/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/vuejs/vue-cli/blob/dev/CHANGELOG.md" target="_blank" rel="noopener noreferrer">https://github.com/vuejs/vue-cli/blob/dev/CHANGELOG.md<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/7063754985581838367" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7063754985581838367<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="如何设计一个通用组件"><a href="#如何设计一个通用组件" class="header-anchor">#</a> 如何设计一个通用组件？</h2> <p>一个再复杂的组件，都是由三部分组成的：属性 prop、插槽 slot、事件 event、，它们构成了 Vue.js 组件的 API。如果你开发的是一个通用组件，那一定要事先设计好这三部分，因为组件一旦发布，后面再修改 API 就很困难了，使用者都是希望不断新增功能，修复 bug，而不是经常变更接口。如果你阅读别人写的组件，也可以从这三个部分展开，它们可以帮助你快速了解一个组件的所有功能。</p> <ul><li>prop 定义了这个组件有哪些可配置的属性</li> <li>插槽 slot，它可以分发组件的内容，比如在组件中定义一个具名插槽或作用域插槽等支持扩展</li> <li>自定义事件 event， 通过 <code>$emit</code>，就可以触发自定义的事件  <code>on-click</code> ，在父级通过  <code>@on-click</code>  来监听。</li></ul> <h2 id="在-vs-code-中调试-vue"><a href="#在-vs-code-中调试-vue" class="header-anchor">#</a> 在 VS Code 中调试 Vue</h2> <p><strong>先决条件</strong></p> <p>请确保你安装了 VS Code 以及适合的浏览器，并且安装激活了最新版的相应的 Debugger 扩展：<code>Debugger for Chrome</code>。</p> <p><strong>在浏览器中展示源代码</strong></p> <p>在可以从 VS Code 调试你的 Vue 组件之前，你需要更新 webpack 配置以构建 source map。做了这件事之后，我们的调试器就有机会将一个被压缩的文件中的代码对应回其源文件相应的位置。这会确保你可以在一个应用中调试，即便你的资源已经被 webpack 优化过了也没关系。</p> <p>如果你使用的是 Vue CLI 3，请设置并更新 vue.config.js 内的 devtool property：</p> <div class="language-js extra-class"><pre class="language-js"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">configureWebpack</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">devtool</span><span class="token operator">:</span> <span class="token string">'source-map'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>从 VS Code 启动应用</strong></p> <blockquote><p>我们这里假设端口号为 8080。如果与实际情况不符 (比如 8080 端口已经被占用且 Vue CLI 为你自动选取了另一个端口号)，可以修改相应的配置。</p></blockquote> <p>点击在 Activity Bar 里的 Debugger 图标来到 Debug 视图，然后点击那个齿轮图标来配置一个 launch.json 的文件，选择 <code>Chrome：Launch</code> 环境。然后将生成的 launch.json 的内容替换成为相应的配置：</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;0.2.0&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;configurations&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;chrome&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;request&quot;</span><span class="token operator">:</span> <span class="token string">&quot;launch&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;vuejs: chrome&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;url&quot;</span><span class="token operator">:</span> <span class="token string">&quot;http://localhost:8080&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;webRoot&quot;</span><span class="token operator">:</span> <span class="token string">&quot;${workspaceFolder}/src&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;breakOnLoad&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token property">&quot;sourceMapPathOverrides&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;webpack:///src/*&quot;</span><span class="token operator">:</span> <span class="token string">&quot;${webRoot}/*&quot;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>sourceMapPathOverrides 配置是为了准确的源码文件映射，将会移除文件后的时间戳等信息，这部分也可以在 webpack 编译中配置，例如在 nuxt 项目中配置 <code>nuxt.config.js</code>:</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token function">extend</span><span class="token punctuation">(</span><span class="token parameter">config<span class="token punctuation">,</span> <span class="token punctuation">{</span> isClient <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 非生产环境开启 source-map</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">PATH_TYPE</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        config<span class="token punctuation">.</span>devtool <span class="token operator">=</span> <span class="token string">'eval-source-map'</span>
        Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>output<span class="token punctuation">,</span> <span class="token punctuation">{</span>
          <span class="token literal-property property">devtoolModuleFilenameTemplate</span><span class="token operator">:</span> <span class="token string">'yanyue404://[resource-path]'</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><strong>断点调试</strong></p> <ol><li><p>在 src 源码中设置一个断点准备调试。</p></li> <li><p>在根目录打开你惯用的终端并使用 Vue CLI 开启这个应用：</p></li></ol> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">npm</span> run serve
</code></pre></div><blockquote><p>注意，调试开始先使用命令行方式将项目启动起来，调试运行的项目 url 地址就是这里启动好的项目。</p></blockquote> <ol start="3"><li><p>来到 Debug 视图，选择“vuejs：chrome”配置，然后按 F5 或点击那个绿色的 play 按钮。</p></li> <li><p>随着一个新的浏览器实例打开 <code>http://localhost:8080</code>，你的断点现在应该被命中了。</p></li></ol> <p><strong>其他替代方案</strong></p> <ul><li><p>Vue Devtools</p></li> <li><p>简单的 debugger 语句</p></li> <li><p>https://v2.cn.vuejs.org/v2/cookbook/debugging-in-vscode.html</p></li></ul> <h2 id="vue-渲染大量数据时应该怎么优化"><a href="#vue-渲染大量数据时应该怎么优化" class="header-anchor">#</a> vue 渲染大量数据时应该怎么优化？</h2> <ol><li>异步渲染组件</li> <li>按需加载局部数据, 分页，虚拟列表，无限下拉刷新</li> <li>js 运行异步处理: 分割任务，实现时间切片处理, 类似 react fiber, 每次执行记录时间, 超过一定执行时间则 settimeout 或 requestAnimation 推迟到下一个时间片,一般一个时间片为 16ms</li> <li>大量纯展示的数据,不需要追踪变化的 用 object.freeze 冻结</li> <li>利用服务器渲染 SSR，在服务端渲染组件</li></ol> <h2 id="vue-如何优化首页的加载速度-vue-首页白屏是什么问题引起的-如何解决呢"><a href="#vue-如何优化首页的加载速度-vue-首页白屏是什么问题引起的-如何解决呢" class="header-anchor">#</a> vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？</h2> <p>首页白屏的原因：单页面应用的 html 是靠 js 生成，因为首屏需要加载很大的 js 文件(app.js vendor.js)，所以当网速差的时候会产生一定程度的白屏</p> <p>解决办法：（按优先级划分）</p> <ul><li>整站 ssr/ssg 服务端渲染，在服务端事先拼装好首页所需的 html</li> <li>使用首屏 SSR + 跳转 SPA 方式来优化，改单页应用为多页应用，需要修改 webpack 的 entry</li> <li>首页加 loading 或 骨架屏 （仅仅是优化体验）</li> <li>优化 webpack 减少模块打包体积，code-split 按需加载</li> <li>使用 Quicklink，在网速好的时候 可以帮助你预加载页面资源</li> <li>接入 service worker 缓存，和 ssr 一起搭配使用更佳</li> <li>常规操作：cdn、减少请求、雪碧图、gzip、浏览器缓存什么的就不多说了</li> <li>非首屏资源，使用 preload、prefetch 避免阻塞渲染进程，减少 FP（首次渲染）时间</li> <li>借助一些工具进行性能评测，重点调优</li></ul> <h2 id="v-if、v-show、v-html-的原理是什么-它是如何封装的"><a href="#v-if、v-show、v-html-的原理是什么-它是如何封装的" class="header-anchor">#</a> v-if、v-show、v-html 的原理是什么，它是如何封装的？</h2> <ul><li>v-if 会调用 addIfCondition 方法，生成 vnode 的时候会忽略对应节点，render 的时候就不会渲染；</li> <li>v-show 会生成 vnode，render 的时候也会渲染成真实节点，只是在 render 过程中会在节点的属性中修改 show 属性值，也就是常说的 display；</li> <li>v-html 会先移除节点下的所有节点，调用 html 方法，通过 addProp 添加 innerHTML 属性，归根结底还是设置 innerHTML 为 v-html 的值</li></ul> <h2 id="vue-在-v-for-时给每项元素绑定事件需要用事件代理吗-为什么"><a href="#vue-在-v-for-时给每项元素绑定事件需要用事件代理吗-为什么" class="header-anchor">#</a> vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？</h2> <p>可以使用</p> <p>事件代理作用主要是 2 个</p> <ol><li>将事件处理程序代理到父节点，减少内存占用率</li> <li>动态生成子节点时能自动绑定事件处理程序到父节点</li></ol> <p>vue 源码内部并不会自动做事件代理，但是一般给 v-for 绑定事件时，都会让节点指向同一个事件处理程序，一定程度上比每生成一个节点都绑定一个不同的事件处理程序性能好，但是监听器的数量仍不会变，所以使用事件代理会更好一点，无论是监听器数量和内存占用率都会要少</p> <h2 id="vue-ssr-有了解吗-原理是什么"><a href="#vue-ssr-有了解吗-原理是什么" class="header-anchor">#</a> Vue SSR 有了解吗？原理是什么？</h2> <p>在客户端请求服务器的时候，服务器到数据库中获取到相关的数据，并且在服务器内部将 Vue 组件渲染成 HTML，并且将数据、HTML 一并返回给客户端，这个在服务器将数据和组件转化为 HTML 的过程，叫做服务端渲染 SSR。</p> <p>而当客户端拿到服务器渲染的 HTML 和数据之后，由于数据已经有了，客户端不需要再一次请求数据，而只需要将数据同步到组件或者 Vuex 内部即可。除了数据意外，HTML 也结构已经有了，客户端在渲染组件的时候，也只需要将 HTML 的 DOM 节点映射到 Virtual DOM 即可，不需要重新创建 DOM 节点，这个将数据和 HTML 同步的过程，又叫做客户端激活。</p> <blockquote><p>Vue.js 服务器端渲染指南的解释：</p></blockquote> <blockquote><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序。</p></blockquote> <blockquote><p>服务器渲染的 Vue.js 应用程序也可以被认为是&quot;同构&quot;或&quot;通用&quot;，因为应用程序的大部分代码都可以在服务器和客户端上运行。</p></blockquote> <p>使用 SSR 的好处：</p> <p>有利于 SEO：其实就是有利于爬虫来爬你的页面，因为部分页面爬虫是不支持执行 JavaScript 的，这种不支持执行 JavaScript 的爬虫抓取到的非 SSR 的页面会是一个空的 HTML 页面，而有了 SSR 以后，这些爬虫就可以获取到完整的 HTML 结构的数据，进而收录到搜索引擎中。</p> <p>白屏时间更短：相对于客户端渲染，服务端渲染在浏览器请求 URL 之后已经得到了一个带有数据的 HTML 文本，浏览器只需要解析 HTML，直接构建 DOM 树就可以。而客户端渲染，需要先得到一个空的 HTML 页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 JavaScript 脚本，越是复杂的应用，需要加载的 JavaScript 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。</p> <p>使用服务器端渲染 (SSR) 时还需要有一些权衡之处：</p> <ul><li><p>开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。</p></li> <li><p>涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。</p></li> <li><p>更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p></li></ul> <p>在对你的应用程序使用服务器端渲染 (SSR) 之前，你应该问的第一个问题是，是否真的需要它。这主要取决于内容到达时间 (time-to-content) 对应用程序的重要程度。例如，如果你正在构建一个内部仪表盘，初始加载时的额外几百毫秒并不重要，这种情况下去使用服务器端渲染 (SSR) 将是一个小题大作之举。然而，内容到达时间 (time-to-content) 要求是绝对关键的指标，在这种情况下，服务器端渲染 (SSR) 可以帮助你实现最佳的初始加载性能。</p> <p>更多详情查看<a href="https://github.com/yacan8/blog/issues/30" target="_blank" rel="noopener noreferrer">彻底理解服务端渲染 - SSR 原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="服务器端渲染-vs-预渲染-ssr-vs-prerendering"><a href="#服务器端渲染-vs-预渲染-ssr-vs-prerendering" class="header-anchor">#</a> 服务器端渲染 vs 预渲染 (SSR vs Prerendering)</h2> <p>如果你调研服务器端渲染 (SSR) 只是用来改善少数营销页面（例如 <code>/</code>, <code>/about</code>, <code>/contact</code> 等）的 SEO，那么你可能需要<strong>预渲染</strong>。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。</p> <p>如果你使用 webpack，你可以使用 <a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener noreferrer">prerender-spa-plugin<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 轻松地添加预渲染。它已经被 Vue 应用程序广泛测试 - 事实上，<a href="https://github.com/chrisvfritz" target="_blank" rel="noopener noreferrer">作者<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是 Vue 核心团队的成员。</p> <h2 id="什么是预渲染-ssg"><a href="#什么是预渲染-ssg" class="header-anchor">#</a> 什么是预渲染(SSG)</h2> <p>预渲染指的是构建时渲染页面 HTML（运行 <code>$vite build</code> 时）</p> <p>如果不使用预渲染，那么页面 HTML 会在请求时渲染（当用户页面导航时）</p> <p>使用预渲染的话，我们不需要 Node.js 服务：我们的应用程序仅包含静态文件（HTML、JS、CSS、images 等），我们可以将其部署到“静态 host”上，比如： GitHub Pages， Cloudflare Pages， 或 Netlify</p> <p>如果不使用预渲染，那么我们需要一个 Node.js 生产环境服务，（或类 Node.js 环境，如：Cloudflare Workers 或 Vercel），以便在请求时动态渲染页面 HTML</p> <blockquote><p>Tools that pre-render pages are also known as &quot;SSG&quot; (Static-Site Generators). 预渲染页面也被称为 “SSG” （静态站点生成器）</p></blockquote> <h2 id="ssg-vs-ssr"><a href="#ssg-vs-ssr" class="header-anchor">#</a> SSG vs SSR</h2> <p>SSG 和 SSR 之间唯一的区别是渲染 HTML 的时间点</p> <ul><li>SSG：页面在构建时渲染（调用 <code>$ vite build</code> 命令时）</li> <li>SSR：页面在请求时渲染（用户进入网页和调用 <code>renderPage()</code> 时）</li></ul> <blockquote><p>客户端代码在用户浏览器中加载执行，始终在请求时执行</p></blockquote> <h2 id="我应该使用预渲染吗"><a href="#我应该使用预渲染吗" class="header-anchor">#</a> 我应该使用预渲染吗？</h2> <p>简言之：我们应该尽可能使用预渲染</p> <p>预渲染不需要 Node.js 服务，这使得部署更简单。其性能也明显更好，因为 HTML 不会在每次请求时重新生成</p> <p>预渲染不能用户所有类型的网站。所以问题来了：我应该使用预渲染吗？</p> <p>预渲染不能用于内容高度动态的网站，例如：Hacker News 或 Reddit：用户每次发布链接或撰写评论时，内容都会发生改变。这种情况下我们不能使用预渲染：a) 预渲染的 HTML 卡在构建时，b) 如果每秒都有新内容，我们无法重新构建整个网站</p> <p>预渲染适用于内容偶尔改变的网站，一天更新几次那种。比如：https://vite-plugin-ssr.com 只是偶尔更新，每次 vite-plugin-ssr 维护者改变内容的时候，整个 https://vite-plugin-ssr.com 都重新构建。预渲染支持把 https://vite-plugin-ssr.com 部署到 Github Pages，这比使用 Node.js 生产服务更容易（并且性能更高）一个数量级。</p> <h2 id="让-vue-使用指定配置文件进行构建"><a href="#让-vue-使用指定配置文件进行构建" class="header-anchor">#</a> 让 Vue 使用指定配置文件进行构建</h2> <p>以 vue-cli 为例, <a href="https://moe.best/gotagota/vue-build-from-specified-config.html" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> spawnSync <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> resolve <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>

<span class="token function">spawnSync</span><span class="token punctuation">(</span><span class="token string">'npm'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'run'</span><span class="token punctuation">,</span> <span class="token string">'build'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">shell</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token literal-property property">env</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>process<span class="token punctuation">.</span>env<span class="token punctuation">,</span> <span class="token comment">// 要记得导入原本的环境变量</span>
    <span class="token constant">VUE_CLI_SERVICE_CONFIG_PATH</span><span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'my.vue.config.js'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">stdio</span><span class="token operator">:</span> <span class="token string">'inherit'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="理解-vue3-composables"><a href="#理解-vue3-composables" class="header-anchor">#</a> 理解 Vue3 composables</h2> <p><strong>Vue3 项目中，一般会有 composables 目录 ，它的作用是什么</strong></p> <p>在 Vue3 项目中，<code>composables</code>  目录主要用于存放你的组合式 API（composable functions）。在 Vue 3.0 中，新增的组合式 API 是一种强大的状态逻辑重用机制，它允许你在多个组件之间共享和重用逻辑，使得你的代码更具可维护性和可读性。</p> <p>组合式 API 是通过  <code>setup</code>  方法以及一系列的新函数（如  <code>ref</code>，<code>reactive</code>，<code>computed</code>，<code>watch</code>  等等）来实现的。这些函数可以组合在一起，形成可重用的函数，通常称为 &quot;composables&quot; 或 &quot;composable functions&quot;。每一个这样的函数可以包含它自己的状态，计算属性和生命周期钩子，并可以在多个组件之间被重用。</p> <p>例如，你可能会创建一个  <code>useUser</code> composable，它会处理用户认证、获取用户信息、登出等相关的功能。然后你可以在任何需要这些功能的组件中使用这个 composable，而无需重复编写相同的代码。</p> <p>这样的代码组织方式会使你的 Vue 项目更清晰、更易于维护，并且更容易测试。因此，一个  <code>composables</code>  目录在 Vue 3 项目中会非常有用。</p> <p><strong>理解 Vue 3 中的 Composables 重用和组织代码的新方式</strong></p> <p>在 Vue 3 中，Composables 是一种新的逻辑复用和代码组织方式。Composables 是组合式 API（Composition API）的一部分，它们是一种函数，可以让你在组件之间共享和重用状态逻辑。这种方式比以前的 Mixins 和高阶组件（HOCs）有更好的可读性和更清晰的逻辑。</p> <p>Composables 是一种函数，通常在  <code>setup()</code>  方法中使用，可以包含自己的状态、计算属性、生命周期钩子等。你可以将 Composables 想象成能够打包和封装组件逻辑的工具。</p> <p>例如，假设你在多个组件中需要处理一些复杂的用户身份验证逻辑。在这种情况下，你可以创建一个  <code>useAuth()</code> Composable，如下：</p> <p>javascript</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">useAuth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>

  <span class="token keyword">function</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token parameter">username<span class="token punctuation">,</span> password</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...登录逻辑...</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">logout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...登出逻辑...</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    user<span class="token punctuation">,</span>
    login<span class="token punctuation">,</span>
    logout
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后，你可以在任何需要用户身份验证的组件中使用这个 Composable：</p> <p>javascript</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> useAuth <span class="token keyword">from</span> <span class="token string">'@/composables/useAuth'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> user<span class="token punctuation">,</span> login<span class="token punctuation">,</span> logout <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useAuth</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// ...使用 user, login, logout...</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...返回给模板...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种方式有很多优点。首先，Composables 可以使你的代码更具可读性，因为它们明确了哪些状态和行为是一起的。其次，它们可以帮助你避免在不同组件之间复制粘贴相同的逻辑，从而使你的代码更易于维护。最后，由于 Composables 是纯粹的 JavaScript 函数，你可以非常容易地为它们编写单元测试。</p> <h2 id="如何编写一个可以在-vue2-和-vue3-项目同时可用的-vue-组件"><a href="#如何编写一个可以在-vue2-和-vue3-项目同时可用的-vue-组件" class="header-anchor">#</a> 如何编写一个可以在 Vue2 和 Vue3 项目同时可用的 Vue 组件？</h2> <ul><li><a href="https://github.com/vueuse/vue-demi" target="_blank" rel="noopener noreferrer">vue-demi<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> - 为 Vue 2 和 3 创建通用库</li></ul> <p>vue2 项目与 Vue3 项目的 h 函数在处理 props 和事件两个方面存在差异，vue-demi 通过判断环境变量来决定使用哪个 h 函数，从而实现兼容性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// https://github.com/wobsoriano/v-perfect-signature/blob/master/src/utils/h-demi.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> h <span class="token keyword">as</span> hDemi<span class="token punctuation">,</span> isVue2 <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue-demi'</span>

<span class="token keyword">interface</span> <span class="token class-name">Options</span> <span class="token punctuation">{</span>
  props<span class="token operator">?</span><span class="token operator">:</span> Record<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> unknown<span class="token operator">&gt;</span>
  domProps<span class="token operator">?</span><span class="token operator">:</span> Record<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> unknown<span class="token operator">&gt;</span>
  on<span class="token operator">?</span><span class="token operator">:</span> Record<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> unknown<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">adaptOnsV3</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">ons</span><span class="token operator">:</span> Record<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> unknown<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ons<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span>
  <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>ons<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">ret<span class="token punctuation">,</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> handler<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    key <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> key<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    key <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">on</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token operator">...</span>ret<span class="token punctuation">,</span> <span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">:</span> handler <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">type</span><span class="token operator">:</span> string <span class="token operator">|</span> Record<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> unknown<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token literal-property property">options</span><span class="token operator">:</span> Options <span class="token operator">&amp;</span> any <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> children<span class="token operator">?</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isVue2<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">hDemi</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> options<span class="token punctuation">,</span> children<span class="token punctuation">)</span>

  <span class="token keyword">const</span> <span class="token punctuation">{</span> props<span class="token punctuation">,</span> domProps<span class="token punctuation">,</span> on<span class="token punctuation">,</span> <span class="token operator">...</span>extraOptions <span class="token punctuation">}</span> <span class="token operator">=</span> options

  <span class="token keyword">const</span> ons <span class="token operator">=</span> <span class="token function">adaptOnsV3</span><span class="token punctuation">(</span>on<span class="token punctuation">)</span>
  <span class="token keyword">const</span> params <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>extraOptions<span class="token punctuation">,</span> <span class="token operator">...</span>props<span class="token punctuation">,</span> <span class="token operator">...</span>domProps<span class="token punctuation">,</span> <span class="token operator">...</span>ons <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">hDemi</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> params<span class="token punctuation">,</span> children<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> h
</code></pre></div><h2 id="vue3-的渲染函数做了如何变化"><a href="#vue3-的渲染函数做了如何变化" class="header-anchor">#</a> Vue3 的渲染函数做了如何变化</h2> <blockquote><p>https://v3-migration.vuejs.org/zh/breaking-changes/render-function-api.html</p></blockquote> <p>以下是更改的简要总结：</p> <ul><li>h 现在是全局导入，而不是作为参数传递给渲染函数</li> <li>更改渲染函数参数，使其在有状态组件和函数组件的表现更加一致</li> <li>VNode 现在有一个扁平的 prop 结构</li></ul> <h3 id="渲染函数参数"><a href="#渲染函数参数" class="header-anchor">#</a> 渲染函数参数</h3> <p><strong>2.x 语法</strong></p> <p>在 2.x 中，render 函数会自动接收 h 函数 (它是 createElement 的惯用别名) 作为参数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Vue 2 渲染函数示例</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>3.x 语法</strong></p> <p>在 3.x 中，h 函数现在是全局导入的，而不是作为参数自动传递。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Vue 3 渲染函数示例</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> h <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="vnode-prop-格式化"><a href="#vnode-prop-格式化" class="header-anchor">#</a> VNode Prop 格式化</h3> <p><strong>2.x 语法</strong></p> <p>在 2.x 中，domProps 包含 VNode prop 中的嵌套列表：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 2.x</span>
<span class="token punctuation">{</span>
<span class="token literal-property property">staticClass</span><span class="token operator">:</span> <span class="token string">'button'</span><span class="token punctuation">,</span>
<span class="token keyword">class</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string-property property">'is-outlined'</span><span class="token operator">:</span> isOutlined <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token literal-property property">staticStyle</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token string">'#34495E'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token literal-property property">style</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">backgroundColor</span><span class="token operator">:</span> buttonColor <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token literal-property property">attrs</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'submit'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token literal-property property">domProps</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">innerHTML</span><span class="token operator">:</span> <span class="token string">''</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token literal-property property">on</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">click</span><span class="token operator">:</span> submitForm <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token string">'submit-button'</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>3.x 语法</strong></p> <p>在 3.x 中，整个 VNode prop 的结构都是扁平的。使用上面的例子，来看看它现在的样子。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 3.x 语法</span>
<span class="token punctuation">{</span>
<span class="token keyword">class</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'button'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string-property property">'is-outlined'</span><span class="token operator">:</span> isOutlined <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token literal-property property">style</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token string">'#34495E'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">backgroundColor</span><span class="token operator">:</span> buttonColor <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'submit'</span><span class="token punctuation">,</span>
<span class="token literal-property property">innerHTML</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
<span class="token literal-property property">onClick</span><span class="token operator">:</span> submitForm<span class="token punctuation">,</span>
<span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token string">'submit-button'</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="注册组件"><a href="#注册组件" class="header-anchor">#</a> 注册组件</h3> <p><strong>2.x 语法</strong></p> <p>在 2.x 中，注册一个组件后，把组件名作为字符串传递给渲染函数的第一个参数，它可以正常地工作：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 2.x</span>
Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'button-counter'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;button @click=&quot;count++&quot;&gt; Clicked {{ count }} times. &lt;/button&gt;</span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'button-counter'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>3.x 语法</strong></p> <p>在 3.x 中，由于 VNode 是上下文无关的，不能再用字符串 ID 隐式查找已注册组件。取而代之的是，需要使用一个导入的 resolveComponent 方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 3.x</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> h<span class="token punctuation">,</span> resolveComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> ButtonCounter <span class="token operator">=</span> <span class="token function">resolveComponent</span><span class="token punctuation">(</span><span class="token string">'button-counter'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>ButtonCounter<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="调试线上-vue-组件"><a href="#调试线上-vue-组件" class="header-anchor">#</a> 调试线上 vue 组件</h2> <blockquote><p>https://mp.weixin.qq.com/s/kO97IkQ17bSuKSsVq-J_cA</p></blockquote> <p>vue2</p> <div class="language- extra-class"><pre class="language-text"><code>// vue devtools 6.6.3，同时支持vue2和vue3

var Vue, walker, node;
walker = document.createTreeWalker(document.body,1);
while ((node = walker.nextNode())) {
  if (node.__vue__) {
    Vue = node.__vue__.$options._base;
    if (!Vue.config.devtools) {
      Vue.config.devtools = true;
      if (window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {
        window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit(&quot;init&quot;, Vue);
        console.log(&quot;==&gt; vue devtools now is enabled&quot;);
      }
    }
    break;
  }
}
</code></pre></div><p>vue3</p> <div class="language- extra-class"><pre class="language-text"><code>// 纯vue3项目，看不到pinia

const el = document.querySelector('#app') || document.querySelector('#__nuxt')
if (!el) {
  console.error('==&gt; #app element not found')
}

const vm = el.__vue_app__
if (!vm) {
  console.error('==&gt; Vue app instance not found on #app')
}

setTimeout(() =&gt; {
  if (window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {
    window.__VUE_DEVTOOLS_GLOBAL_HOOK__.apps.push({
      app: vm,
      version: vm.version,
      types: {
        Comment: Symbol('Comment'),
        Fragment: Symbol('Fragment'),
        Static: Symbol('Static'),
        Text: Symbol('Text')
      }
    })
    window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('init', vm)
    console.log('==&gt; Vue DevTools now is enabled')
  } else {
    console.error(
      '==&gt; Vue DevTools hook not found, ensure the extension is installed'
    )
  }
}, 1000) // 延迟 1 秒，确保 Vue 挂载完成

</code></pre></div><h2 id="当我们在写-vue2-和-vue3-的代码时-使用-nexttick-时意味着什么"><a href="#当我们在写-vue2-和-vue3-的代码时-使用-nexttick-时意味着什么" class="header-anchor">#</a> 当我们在写 vue2 和 vue3 的代码时，使用 <code>nextTick(() =&gt; {})</code> 时意味着什么</h2> <p>在 Vue2 和 Vue3 中，<code>nextTick(() =&gt; {})</code> 的作用是<strong>将回调函数推迟到下一个 DOM 更新周期之后执行</strong>，以确保在 DOM 更新完成后运行某些操作。以下是对其含义的详细解释：</p> <hr> <h3 id="_1-背景-vue-的响应式更新机制"><a href="#_1-背景-vue-的响应式更新机制" class="header-anchor">#</a> <strong>1. 背景：Vue 的响应式更新机制</strong></h3> <p>Vue 是响应式框架，当数据（<code>data</code> 或 <code>reactive</code>/<code>ref</code>）发生变化时，Vue 不会立即更新 DOM，而是将更新任务放入一个<strong>异步队列</strong>（通常基于 <code>Promise</code> 或 <code>setTimeout</code>），并在当前事件循环的微任务阶段批量执行 DOM 更新。这种机制提高了性能，避免了不必要的重复渲染。</p> <p>然而，这也意味着在修改数据后，DOM 不会立刻反映最新的状态。如果需要在 DOM 更新后执行某些操作（比如获取最新的 DOM 元素或其属性），直接在修改数据后操作可能会获取到旧的 DOM 状态。这时就需要使用 <code>nextTick</code>。</p> <hr> <h3 id="_2-nexttick-的作用"><a href="#_2-nexttick-的作用" class="header-anchor">#</a> <strong>2. <code>nextTick</code> 的作用</strong></h3> <p><code>nextTick</code> 是一个工具函数，允许开发者在 DOM 更新完成后执行回调。它本质上是将回调函数推迟到**下一个微任务（microtask）**执行，确保在数据变化触发 DOM 更新后，DOM 已经完成渲染。</p> <ul><li><strong>Vue2</strong>：<code>this.$nextTick(() =&gt; {})</code> <ul><li>在实例方法中通过 <code>this.$nextTick</code> 调用。</li> <li>全局 API 是 <code>Vue.nextTick</code>。</li></ul></li> <li><strong>Vue3</strong>：<code>nextTick(() =&gt; {})</code> <ul><li>Vue3 中，<code>nextTick</code> 是一个全局导入的函数，通常从 <code>vue</code> 包中导入：<code>import { nextTick } from 'vue'</code>。</li> <li>Composition API 和 Options API 都可以使用。</li></ul></li></ul> <hr> <h3 id="_3-具体含义"><a href="#_3-具体含义" class="header-anchor">#</a> <strong>3. 具体含义</strong></h3> <p>当你调用 <code>nextTick(() =&gt; {})</code> 时：</p> <ul><li><strong>延迟执行</strong>：回调函数不会立即执行，而是被放入微任务队列，等待当前事件循环的同步代码执行完毕，并在 DOM 更新完成后运行。</li> <li><strong>确保 DOM 更新</strong>：在回调执行时，Vue 已完成对 DOM 的重新渲染，你可以安全地访问最新的 DOM 状态。</li> <li><strong>异步特性</strong>：<code>nextTick</code> 通常基于 <code>Promise.resolve().then()</code> 实现（在不支持 Promise 的环境中可能降级为 <code>setTimeout</code>）。</li></ul> <hr> <h3 id="_4-使用场景"><a href="#_4-使用场景" class="header-anchor">#</a> <strong>4. 使用场景</strong></h3> <p>以下是 <code>nextTick</code> 的常见使用场景：</p> <h4 id="_1-获取更新后的-dom"><a href="#_1-获取更新后的-dom" class="header-anchor">#</a> <strong>(1) 获取更新后的 DOM</strong></h4> <p>当你修改了响应式数据后，DOM 不会立即更新。如果需要操作最新的 DOM 状态，可以使用 <code>nextTick</code>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// Vue2</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">'新内容'</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>myElement<span class="token punctuation">.</span>innerText<span class="token punctuation">)</span> <span class="token comment">// 确保获取更新后的 DOM 内容</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// Vue3</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> nextTick <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">const</span> message <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'旧内容'</span><span class="token punctuation">)</span>
message<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">'新内容'</span>
<span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.my-element'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText<span class="token punctuation">)</span> <span class="token comment">// 获取更新后的 DOM</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="_2-解决异步渲染导致的逻辑问题"><a href="#_2-解决异步渲染导致的逻辑问题" class="header-anchor">#</a> <strong>(2) 解决异步渲染导致的逻辑问题</strong></h4> <p>在某些复杂组件中，数据更新可能导致 DOM 的多次渲染，使用 <code>nextTick</code> 可以确保逻辑在 DOM 稳定后执行：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// Vue3 示例</span>
<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
count<span class="token punctuation">.</span>value<span class="token operator">++</span>
count<span class="token punctuation">.</span>value<span class="token operator">++</span>
<span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 确保 DOM 已更新到 count 的最新值</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="_3-在单元测试中"><a href="#_3-在单元测试中" class="header-anchor">#</a> <strong>(3) 在单元测试中</strong></h4> <p>在测试环境中，<code>nextTick</code> 常用于等待 DOM 更新完成，以便验证渲染结果：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">await</span> <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 等待 DOM 更新</span>
<span class="token function">expect</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toContain</span><span class="token punctuation">(</span><span class="token string">'新内容'</span><span class="token punctuation">)</span>
</code></pre></div><hr> <h3 id="_5-vue2-和-vue3-的差异"><a href="#_5-vue2-和-vue3-的差异" class="header-anchor">#</a> <strong>5. Vue2 和 Vue3 的差异</strong></h3> <p>虽然 <code>nextTick</code> 的核心功能在 Vue2 和 Vue3 中一致，但有一些细微差异：</p> <ul><li><strong>调用方式</strong>：
<ul><li>Vue2：<code>this.$nextTick</code>（实例方法）或 <code>Vue.nextTick</code>（全局）。</li> <li>Vue3：统一使用全局 <code>nextTick</code> 函数（<code>import { nextTick } from 'vue'</code>）。</li></ul></li> <li><strong>实现细节</strong>：
<ul><li>Vue2 和 Vue3 都优先使用 <code>Promise</code> 实现 <code>nextTick</code>，但 Vue3 的代码更现代化，且与 Composition API 集成更紧密。</li></ul></li> <li><strong>上下文</strong>：
<ul><li>在 Vue2 中，<code>this.$nextTick</code> 的回调函数中的 <code>this</code> 自动绑定到当前组件实例。</li> <li>在 Vue3 中，<code>nextTick</code> 的回调是普通函数，需手动管理上下文（例如通过 <code>ref</code> 或 <code>reactive</code> 访问数据）。</li></ul></li></ul> <hr> <h3 id="_6-注意事项"><a href="#_6-注意事项" class="header-anchor">#</a> <strong>6. 注意事项</strong></h3> <ul><li><strong>不要滥用 <code>nextTick</code></strong>：只有在需要明确等待 DOM 更新时才使用 <code>nextTick</code>，否则可能增加代码复杂性。</li> <li><strong>异步行为</strong>：<code>nextTick</code> 是异步的，回调不会立即执行。如果需要同步操作，请直接操作数据或 DOM。</li> <li><strong>性能考虑</strong>：<code>nextTick</code> 的回调会在微任务队列中执行，通常很快，但如果回调中包含复杂逻辑，可能影响性能。</li></ul> <hr> <h3 id="_7-总结"><a href="#_7-总结" class="header-anchor">#</a> <strong>7. 总结</strong></h3> <p><code>nextTick(() =&gt; {})</code> 的核心含义是<strong>延迟回调到 DOM 更新完成后执行</strong>，用于确保在数据变化后操作最新的 DOM 状态。它在 Vue2 和 Vue3 中功能一致，但在调用方式和上下文管理上略有不同。典型场景包括获取更新后的 DOM、处理异步渲染逻辑或在测试中等待渲染完成。</p> <p>如果你有具体的代码案例或更详细的问题，可以提供进一步分析！</p> <h2 id="参考链接"><a href="#参考链接" class="header-anchor">#</a> 参考链接</h2> <ul><li>https://juejin.cn/post/6844904166742048782</li> <li>https://github.com/haizlin/fe-interview/labels/vue</li> <li>https://github.com/yacan8/blog/issues/31</li> <li>https://github.com/Advanced-Frontend/Daily-Interview-Question/labels/Vue</li> <li>https://v2.ssr.vuejs.org/zh/</li> <li>https://cn.vite-plugin-ssr.com/pre-rendering</li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/yanyue404/fe-attitude/edit/master/site/fe/vue.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">4/18/2025, 4:18:43 AM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/fe-attitude/assets/js/app.7a42581c.js" defer></script><script src="/fe-attitude/assets/js/2.e3af99bf.js" defer></script><script src="/fe-attitude/assets/js/5.e978ac0b.js" defer></script>
  </body>
</html>
