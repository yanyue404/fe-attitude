<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      body {
        background: #000;
        text-align: center;
        overflow: hidden;
      }
      canvas {
        background: #000;
      }
    </style>
  </head>
  <body>
    <canvas id="c" width="800" height="600">
      <!-- 低版本处理方法 -->
      <span style="color: #fff;"
        >您的浏览器版本过低了！不支持canvas，请更新您的IE浏览器至最新版，或使用chrome/firefox浏览器进行访问</span
      >
    </canvas>
  </body>
  <script>
    let oC = document.getElementById('c');
    let gd = oC.getContext('2d'); // 绘图接口(上下文)

    let winW = document.documentElement.clientWidth;
    let winH = document.documentElement.clientHeight;

    let rnd = (n, m) => {
      return parseInt(Math.random() * (m - n) + n);
    };
    let drawPoint = p => {
      let pW = 1;
      let pH = 1;
      gd.fillStyle = '#fff';
      gd.fillRect(p.x - pW / 2, p.y - pH / 2, pW, pH);
    };

    oC.width = winW;
    oC.height = winH;

    let N = 6;

    let point = [];

    let len = 10; // 线的个数
    let oldList = []; // 原有线路点
    for (let i = 0; i < N; i++) {
      point[i] = {
        x: rnd(0, winW),
        y: rnd(0, winH),
        speedX: rnd(-10, 10),
        speedY: rnd(-10, 10),
      };
    }

    setInterval(() => {
      gd.clearRect(0, 0, oC.width, oC.height);
      point.map(item => drawPoint(item));
      // 运动
      point.map(item => {
        if (item.x <= 0) {
          item.x = 0;
          item.speedX *= -1;
        } else if (item.x > winW) {
          item.x = winW;
          item.speedX *= -1;
        }

        if (item.y <= 0) {
          item.y = 0;
          item.speedY *= -1;
        } else if (item.y > winH) {
          item.y = winH;
          item.speedY *= -1;
        }

        item.x += item.speedX;
        item.y += item.speedY;
      });

      // 连起来(画线)
      gd.beginPath();
      gd.strokeStyle = `rgba(255, ${len}, 255, 1)`;
      gd.moveTo(point[0].x, point[0].y);
      point.map(item => gd.lineTo(item.x, item.y));
      gd.closePath();
      gd.stroke();

      // 重复画(尾巴)
      let list = [];
      point.map((item, index) => {
        list[index] = {
          x: item.x,
          y: item.y,
        };
      });
      oldList.push(list);

      if (oldList.length > len) {
        oldList.shift();
      }

      oldList.map((item, index) => {
        let opacity = 1 - index / oldList.length;
        gd.strokeStyle = `rgba(255, ${oldList.length}, 255, ${opacity})`;
        gd.beginPath();
        gd.moveTo(oldList[index][0].x, oldList[index][0].y);
        for (let i = 0; i < N; i++) {
          gd.lineTo(oldList[index][i].x, oldList[index][i].y);
        }
        gd.closePath();
        gd.stroke();
      });
    }, 16);
  </script>
</html>
