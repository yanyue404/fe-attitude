<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>

  <body>
    <script>
      var a = ['A', 'B', 'C'];
      var s = new Set(['A', 'B', 'C']);
      var m = new Map([
        [1, 'x'],
        [2, 'y'],
        [3, 'z'],
      ]);
      for (var x of a) {
        // 遍历Array
        console.log(x); //'A', 'B', 'C'
      }
      for (var x of s) {
        // 遍历Set
        console.log(x); //'A', 'B', 'C'
      }
      for (var x of m) {
        // 遍历Map
        console.log(x[0] + '=' + x[1]); //1='x',2='y',3='z'
      }

      // for … in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。
      // 当我们手动给Array对象添加了额外的属性后，for … in循环将带来意想不到的意外效果：
      // for … in循环将把name包括在内，但Array的length属性却不包括在内。
      var a = ['A', 'B', 'C'];
      a.name = 'Hello';
      for (var x in a) {
        console.log(x); // '0', '1', '2', 'name'
      }

      // for … of循环则完全修复了这些问题，它只循环集合本身的元素
      var a = ['A', 'B', 'C'];
      a.name = 'Hello';
      for (var x of a) {
        console.log(x); // 'A', 'B', 'C'
      }
    </script>
  </body>
</html>
