## GET 和 POST 的区别有哪些？

- get: 可缓存、请求长度受限、会被历史保存记录，无副作用(不修改资源)，幂等(请求次数与资源无关)的场景
- post: 安全一点、大数据、支持更多编码类型

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/14/168e9d9050b9d08a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

**post 请求的编码格式**

1. application/x-www-form-urlencoded
2. application/form-data
3. application/json

## POST 和 PUT 请求的区别

- PUT 请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次 PUT 操作，其结果并没有不同。（可以理解为时更新数据）
- POST 请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是创建数据）

## TCP 三次握手和四次挥手是什么？

**三次握手**

![](https://upload-images.jianshu.io/upload_images/9658881-14388ff91eda35c6.png?imageMogr2/auto-orient/strip|imageView2/2/w/855/format/webp)

三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。

1. **第一次握手([SYN], Seq = x)**

客户端发送一个 SYN 标记的包，Seq 初始序列号 x，发送完成后客户端进入`SYN_SEND`状态。

2. **第二次握手([SYN,ACK], Seq = y, ACK = x + 1)**

服务器返回确认包(ACK)应答，同时还要发送一个 SYN 包回去。ACK = x + 1,表示确认收到(客户端发来的 Seq 值 + 1)，Seq = y, 表示让客户端确认是否能收到。发送完成后`服务端`进入`SYN_RCVD（received 缩写，收到）`状态。

3. **第三次握手([ACK], ACK = y + 1)**

客户端再次发送确认包(ACK),ACK = y + 1, 表示确认收到服务器的包（服务端发来的 Seq 值 + 1）。`客户端`发送完毕后，进入`ESTABLISHED（建立了）`状态，`服务端`接收到这个包，也进入`ESTABLISHED`状态, TCP 握手结束。

> 换一种抽象派的方式解释：
>
> （1）客户端：hello，你是 server 么？
>
> （2）服务端：hello，我是 server，你是 client 么?
>
> （3）客户端：yes，我是 client

**四次挥手**

建立连接成功后，接下来就正式传输数据

然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）

![](https://upload-images.jianshu.io/upload_images/9658881-bee754e3da92d278.png?imageMogr2/auto-orient/strip|imageView2/2/w/835/format/webp)

TCP 连接的断开需要发送四个包，所以称为四次挥手。

1. 第一次挥手（[FIN], Seq = x）

客户端发送一个 FIN 标记的包，告诉服务器需要关闭连接，表示自己不用发送数据了，但是还可以接收数据。发送完成后，`客户端`进入 `FIN_WAIT_1` 状态。

2. 第二次挥手 ([ACK], ACK = x + 1)

服务端发送一个 ACK 的确认包，告诉客户端接收到关闭的请求，但是还没有准备好。发送完成后，`服务端`进入 `CLOSE_WAIT` 状态，`客户端`收到这个包后，进入 `FIN_WAIT_2`，等待服务器关闭连接。

3. 第三次挥手 ([FIN], Seq = y)

服务端准备好关闭连接时，发送 FIN 标记的包，告诉客户端准备关闭了。发送完成后，`服务端`进入 `LAST_ACK` 状态，等待客户端确认。

4. 第四次挥手 ([ACK], ACK = y + 1)

客户端接收到服务端的关闭请求，再发送 ACK 标记的确认包，进入 `TIME_WAIT` 状态，等待服务端可能请求重传的 ACK 包。

服务端接收到 ACK 包后，关闭连接，进入 `CLOSED` 状态。

客户端在`等待固定时间(两个最大段生命周期)后，没有接收到服务的 ACK 包`，认为服务器已关闭连接，自己也关闭连接，进入 `CLOSED` 状态。

> 同样换一种抽象派的方式解释：
>
> （1）主动方：我已经关闭了向你那边的主动通道了，只能被动接收了
>
> （2）被动方：收到通道关闭的信息
>
> （3）被动方：那我也告诉你，我这边向你的主动通道也关闭了
>
> （3）主动方：最后收到数据，之后双方无法通信

**为什么要"三次握手，四次挥手"**

1. 三次握手

换个易于理解的视角来看为什么要 3 次握手。

客户端和服务端通信前要进行连接，“3 次握手”的作用就是`双方都能明确自己和对方的收、发能力是正常的`。

`第一次握手`：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

`第二次握手`：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。

`第三次握手`：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。

每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？

而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。

2. 四次挥手

TCP 连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个 ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK 确认关闭连接。注意，接收到 FIN 报文的一方只能回复一个 ACK, 它是无法马上返回对方一个 FIN 报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。

参考链接

- https://zhuanlan.zhihu.com/p/53374516
- https://www.jianshu.com/p/12790cea57ac

## HTTP 缓存有哪些方案？

- 缓存策略: 可分为 强缓存 和 协商缓存

  - Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，Cache-Control 的 max-age 优先级高于 Expires
  - 当缓存已经过期时，使用协商缓存
    - 唯一标识方案: Etag(response 携带) & If-None-Match(request 携带，上一次返回的 Etag): 服务器判断资源是否被修改，
    - 最后一次修改时间: Last-Modified(response) & If-Modified-Since (request，上一次返回的 Last-Modified)
      - 如果一致，则直接返回 304 通知浏览器使用缓存
      - 如不一致，则服务端返回新的资源
  - Last-Modified 缺点：

    - 周期性修改，但内容未变时，会导致缓存失效
    - 最小粒度只到 s， s 以内的改动无法检测到

  - Etag 的优先级高于 Last-Modified

## HTTP/1.1 和 HTTP/2 的区别有哪些？

1. HTTP/2 使用了二进制传输，而且将 head 和 body 分成帧来传输；HTTP/1.1 是字符串传输。
2. HTTP/2 支持多路复用，HTTP/1.1 不支持。多路复用简单来说就是一个 TCP 连接从单车道（不是单行道）变成了几百个双向通行的车道。
3. HTTP/2 可以压缩 head，但是 HTTP/1.1 不行。
4. HTTP/2 支持服务器推送，但 HTTP/1.1 不支持。

## HTTP 和 HTTPS 的区别有哪些？

HTTPS = HTTP + SSL/TLS（安全层）

1. HTTP 是明文传输的，不安全；HTTPS 是加密传输的，比较安全。
2. HTTP 使用 80 端口，HTTPS 使用 443 端口。
3. HTTP 较快，HTTPS 较慢。
4. HTTPS 的证书一般需要购买（但也有免费的），HTTP 不需要证书。

## http/https 协议

- `http1.0`中，默认使用的是短连接，也就是说，浏览器每进行一次 http 操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接，
  - 无法复用链接，完成即断开，重新慢启动和 TCP 3 次握手
  - head of line blocking: 线头阻塞，导致请求之间互相影响
- `http1.1` 起，默认使用长连接，使用长连接会有这一行`Connection: keep-alive`，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输 http 的 tcp 连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接
  - host 字段指定对应的虚拟站点
  - 新增功能:
    - 断点续传
    - 身份认证
    - 状态管理
    - cache 缓存
      - Cache-Control
      - Etag
- `http2.0`

  - 多路复用（即一个 tcp/ip 连接可以请求多个资源）
  - 首部压缩（http header 编码压缩，减少体积）
  - 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）
  - 服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）
  - 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器对请求的响应设置优先级权重，决定需要多少资源来处理该请求。）

- https: 较为安全的网络传输协议
  - 证书(公钥)
  - SSL 加密
  - 端口 443

注意： **keep-alive 不会永远保持，它有一个持续时间，一般在服务器中配置（如 apache），另外长连接需要客户端和服务器都支持时才有效**

## Websocket

WebSocket 是 HTML5 提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于 TCP 传输协议，并复用 HTTP 的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。

WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。

WebSocket 原理：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者 ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有 ID 在接收者 ID 序列中的客户端才会处理这个事件。

WebSocket 特点的如下：

- 支持双向通信，实时性更强
- 可以发送文本，也可以发送二进制数据‘’
- 建立在 TCP 协议之上，服务端的实现比较容易
- 数据格式比较轻量，性能开销小，通信高效
- 没有同源限制，客户端可以与任意服务器通信
- 协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL
- 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

Websocket 的使用方法如下：

在客户端中：

```js
// 在index.html中直接写WebSocket，设置服务端的端口号为 9999
let ws = new WebSocket('ws://localhost:9999')
// 在客户端与服务端建立连接后触发
ws.onopen = function() {
  console.log('Connection open.')
  ws.send('hello')
}
// 在服务端给客户端发来消息的时候触发
ws.onmessage = function(res) {
  console.log(res) // 打印的是MessageEvent对象
  console.log(res.data) // 打印的是收到的消息
}
// 在客户端与服务端建立关闭后触发
ws.onclose = function(evt) {
  console.log('Connection closed.')
}
```

> 单工通信，收发方固定；半双工通信，收发方不固定，但同一时刻只能一方发一方收；全双工通信，双发可同时收发。

> 各种通信和网络书籍上对于全双工和半双工的经典举例一般就是电话和对讲机。

> 如果以生活中的例子来说，可以理解为只能过一辆车的桥，和双向各一车道的桥。前者同时只有一个方向可以过，后者来回双向都可以同时过。
